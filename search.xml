<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[分组交换的报文交付时间]]></title>
    <url>%2F2020%2F03%2F07%2F%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%9A%84%E6%8A%A5%E6%96%87%E4%BA%A4%E4%BB%98%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[分组交换的报文交付时间 首先对在公式中需要的一些变量进行说明：假设我们有 $M bits$ 的报文需要进行发送，采用分组交换的方式进行发送，假设分组的长度（大小）为 $L\ bits$ .假设链路带宽（数据传输速率）为 $R\ bps$ .假设从发送方到接收方的跳步数为 $h$, 路由器 数为 $n$ .那么我们可以得到分组交付时间 $T$的计算公式如下： \begin{aligned} T &=M / R+(h-1) L / R \\ &=M / R+n L / R \end{aligned} \tag{1}下面给出上面 公式${1}$ 的推导过程： 由于采用分组交换的方式，因此从发送开始计时，经过时间$L/R$,源端系统的发送的第一个分组经过一个跳步达到第一个路由器； 经过第二个$L/R$此时源端系统发送了两个分组，同时第二个第二个路由器也收到了第一个路由器转发的分组； 重复上面的过程，经过时间$(L/R)*h$，目的端系统收到了第一个分组; 此后每经过一个时间$L/R$目的端系统就收到一个分组，总的分组数量为$M/L$,同时由于已经接收到了一个分组，因此还需要接收$M/L-1$个分组.由此我们得到总的交付时间的计算公式 $2$ \begin{aligned} T &=h* L / R+(M/L-1) L / R \\ &=M / R+(h-1) L / R \end{aligned} \tag{2}显然我们知道跳步数和路由器数之间存在这样的关系$n=h-1$,将其带入 公式$2$ 因此我们最后得到的公式为 \begin{aligned} T &=M / R+n L / R \end{aligned} \tag{3}示例下面我们通过以2009年全国计算机考研中的一道试题来加深对上面推导过程的理解： 在下图所示的采用“存储-转发”方式的分组交换网络中，所有链路的数据传输速率为$100 Mbps$, 分组大小为$1 000 B$ ,其中分组的头部大小为$20 B$. 若主机H1向主机H2发送一个大小为$980 000B$ 的文件，则在不考虑分组拆装时间和传播延迟的情况下，从H1发送开始到H2接收完为止，需要的时间至少是多少？ 【分析&amp;求解】：由于题目中需要计算的是一个最小 时间，因此我们需要选择图中上面的一条链路进行计算.我们还需要计算$980 000B$的数据需要拆分为多少个分组.由于每个分组大小为$1 000B$，我们假设有$x$个分组，因此可以列出下面方程： 1000x = 980000+20x解上面方程我们知道有$1000$个分组，由于在发送数据的过程中头部数据也需要进行发送，因此我们按 公式${1}$ 列出下面的算式计算得到时间$T$： \begin{aligned} T &= (980000+20×1000)×8/100M + 2×1000×8/100M \\ &=80.16 ms \end{aligned}因此，从H1发送开始到H2接收完为止，需要的时间至少是80.16ms.]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML表格]]></title>
    <url>%2F2020%2F02%2F19%2FHTML%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[HTML表格 表格：&lt;table&gt;&lt;/table&gt;, 行标签&lt;tr&gt;&lt;/tr&gt;,单元格(放在相应的行标签内) &lt;td&gt;&lt;/td&gt;，三个标签逐层包含 默认没有边线，通过属性 border = &quot;1&quot;可以增加简单边线； 表头&lt;th&gt;&lt;/th&gt;，此时内容加粗，居中显示 宽度 width = 500px 表格标题 &lt;caption&gt;&lt;/caption&gt;,必须紧跟在&lt;table&gt;标签之后，且一个表格只能有一个标题 表格结构标签，对表格进行分组，结构划分，优化显示：表格的头&lt;thead&gt;，表格主体&lt;tbody&gt;， 表格脚注&lt;tfoot&gt; &lt;table&gt;表格属性： 表格宽度width, 默认为内容宽度 &lt;table&gt;表格属性：外边框宽度border &lt;table&gt;表格属性： 表格相对周围元素的对齐方式align,可以有left,center,right &lt;table&gt;表格属性： 表格背景颜色 Bgcolor,可以通过rgb( , , ),#××××和Colorname设置 &lt;table&gt;表格属性：单元边沿与其内容之间的空白Cellpandding,可以通过pixels或者百分比进行设置 &lt;table&gt;表格属性：单元格之间的空白cellspacing，通过pixels或者百分比进行设置 &lt;table&gt;表格属性： 规定外侧边框哪个部分是可见的frame，值有void,above,below,hsides,vsides,lhs,rhs,box,border &lt;table&gt;表格属性：规定内侧边框哪个部分是可见的rules，值有none,groups, rows, cols, all &lt;tr&gt;标签属性：行内容水平对齐align，值可以有Left,center,right,justify,char &lt;tr&gt;标签属性：行内容垂直对齐方式， Valign值可以有top,middle, bottom,baseline &lt;tr&gt;标签属性：行的背景颜色Bgcolor &lt;td&gt;和&lt;th&gt;标签属性：align单元格的水平对齐方式 &lt;td&gt;和&lt;th&gt;标签属性：valign单元格的垂直对齐方式 &lt;td&gt;和&lt;th&gt;标签属性：bgcolor单元格的背景颜色 &lt;td&gt;和&lt;th&gt;标签属性：width单元格的宽度 &lt;td&gt;和&lt;th&gt;标签属性：height单元格的高度 &lt;thead&gt;、&lt;tbdoy&gt;和&lt;tfoot&gt;标签属性：align，valign 跨列属性 clospan = 2,在相应的标签中进行设置，并对标签的数量进行改变 跨行属性rowspan,也是写在相应的单元格标签内 表格嵌套：嵌入的表格要是完整结构，并放在标签内部]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础]]></title>
    <url>%2F2020%2F02%2F19%2FHTML%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[HTML基础 html基本结构：html文件&lt;html&gt;&lt;/html&gt;,头部信息,网页主体内容&lt;body&gt;&lt;/body&gt; 水平线：&lt;hr/&gt;（单标签） 段落标签：&lt;p&gt;&lt;/p&gt; 元素：开始标签+内容+结束 颜色：bgcolor = “red”，开始标签后面添加标签属性，属性与属性之间用空格隔开 注释：&lt;!--注释内容--&gt; 声明doctype类型，放在html文档第一行，&lt;!DOCTYPE html&gt; (不是标签) 解决乱码在&lt;head&gt;&lt;/head&gt;标签之间添加：&lt;meta http-equiv =&quot;Content&quot; content = &quot;text/html; charse = utf-8&quot;/&gt; 标题标签&lt;h1&gt;&lt;/h1&gt;~&lt;h6&gt;&lt;/h6&gt; 段落标签 &lt;p&gt;&lt;/p&gt; 换行标签 &lt;br/&gt; 对齐属性 ： left，right， center， justify(对行进行延伸，这样每行都有相同的长度)。 换行标签，&lt;br/&gt;，可以使该标签后面的换行 空格 &amp;nbsp; 保留编辑器中的文本格式：&lt;pre&gt;&lt;/pre&gt; 水平线 &lt;hr/&gt;， 属性：width（设置像素或者百分比），color, align, noshade(设置水平线无阴影) 修饰标签: 文字斜体&lt;i&gt;&lt;/i&gt;、&lt;em&gt;&lt;/em&gt;,加粗&lt;b&gt;&lt;/b&gt;、&lt;strong&gt;&lt;/strong&gt;， 下标&lt;sub&gt;&lt;/sub&gt;， 上标 &lt;sup&gt;&lt;/sup &gt;, 下划线&lt;ins&gt;, 删除线 &lt;del&gt; 特殊符号：&lt; &amp;lt;,&gt;&amp;gt, 已注册&amp;reg,版权&amp;copy, 商标&amp;trade, 不断行空白&amp;nbsp 无序列表：&lt;ul&gt;&lt;/ul&gt;,中间内容:&lt;li&gt;&lt;/li&gt;,type属性设置列表符号形状:disc,square,circle 有序列表：&lt;ol&gt;&lt;/ol&gt;，中间列表项：&lt;li&gt;&lt;/li&gt;，type属性值1，a, A, i(小写罗马数字), I（大写罗马数字） 定义列表：&lt;dl&gt;&lt;/dl&gt;,定义列表项：&lt;dt&gt;&lt;/dt&gt;,定义列表描述：&lt;dd&gt;&lt;/dd&gt;(定义列表内可以多个定义列表项，每个定义列表项中可以多个定义列表项描述） 图案标签（单标签）：&lt;img src = &quot; &quot; alt = &quot; &quot;..../&gt; img属性： src值为URL,alt值为文字（无法正常显示图像的时候进行文字的显示），height值为数值和百分比， width值为数值和百分比； HTML路径：相对路径，绝对路径 超链接标签：&lt;a href = &quot; &quot;&gt;内容&lt;/a&gt; 站内链接：相对路径； 站外链接：绝对路径； 空链接（链接效果但不确定链接目标）：href设置为#，点击不会产生跳转 链接属性：target链接的目标窗口，默认为当前页面，_self: 当前页面，_blank:创建新的窗口打开页面，_top, _parent；title链接的提示文字； name链接的命名; 定义锚(跳转相应起始点位置)：&lt;a href = &quot;#锚名1&quot;&gt;目录1&lt;/a&gt;,&lt;a href = &quot;...&quot; name =“锚名1”&gt;内容&lt;/a&gt;; 不同页面定义锚：网页1 &lt;a href = “网页名称#锚名”&gt;...&lt;/a&gt;;网页2 &lt;a name = &quot;锚名&quot;&gt; ... &lt;/a &gt;; 邮件链接：&lt;a href = &quot;mailto:邮件地址&quot;&gt;...&lt;/a&gt; 文件下载： &lt;a href = &quot;下载文件的地址&quot;&gt;...&lt;/a&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机网络——自顶向下方法》运输层——无连接运输：UDP]]></title>
    <url>%2F2020%2F02%2F19%2F%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94%E6%97%A0%E8%BF%9E%E6%8E%A5%E8%BF%90%E8%BE%93%EF%BC%9AUDP%2F</url>
    <content type="text"><![CDATA[无连接运输：UDP 运输层最低限度必须提供一种复用、分解服务，以便在网络层与正确的应用及进程之间传递数据。UDP就是只做了运输层协议能够做的最少工作。除了复用/分解功能及少量的差错检测之外，它几乎没有对IP增加别的东西。在使用UDP时，发送方和接收方的运输层实体之间没有握手，正因为如此，UDP被称为是无连接的。既然TCP提供了可靠的数据传输服务，而UDP不能提供，那么TCP是否总是首选？答案是否定的，因为许多应用程序更适合用UDP,原因主要有以下几点： 关于合适、发送什么数据的应用层控制更为精细； 无需连接建立 ,UDP不会引起建立连接的时延； 无连接状态 ,TCP需要在端系统中维护连接状态，此连接状态包括接收和发送缓存，拥塞控制参数以及序号与确定号参数。要实现TCP可靠数据传输与拥塞控制这些状态信息是必要的。另一方面，UDP不需要维护这些状态信息，也不跟踪这些参数，因此，某些撞门用于某种特定应用的服务器当应用程序运行在UDP而不是在TCP上时，一般都能支持更多的活跃用户。 分组首部开销小， 每个TCP报文段都有20字节的首部开销，而UDP仅有8字节的开销。需要提出的是：使用UDP的应用时可以实现可靠数据传输的，这可以通过在应用程序自身中建立可靠机制来完成。UDP报文段结构UDP报文段结构如下图所示。应用层数据占用UDP报文段的数据字段。UDP的首部只有4个字段，每个字段有两个字节组成。通过端口号可以使目的主机将应用数据交给运行在目的端系统中的相应进程。长度字段指示了在UDP报文段中的字节数（首部加数据）。因为数据字段的长度在一个UDP段中不用一在另一个段中，故需要一个明确的长度。接收方使用检验和来检查该报文段中是否出现了差错。实际上计算检验和时，除了UDP报文段以外还包括了IP首部的一些字段。UDP检验和UDP检验和提供了差错检测功能。检验和用于确定当UDP报文段从源到达目的地移动时，其中的比特是否发生了改变。发送方的UDP报文段中的所有16比特的字的和进行反码运算，求和遇到溢出时都被回卷（将异常位加到最低位）。得到的结果放在UDP报文段中的检验和字段。举例来说我们有下满3个16比特的字： \begin{aligned} &0110011001100000\\ &0101010101010101\\ &1000111100001100 \end{aligned}这些16比特的字的前两个之和是： \begin{aligned} &0110011001100000\\ &\frac{0101010101010101}{1011101110110101} \end{aligned}再将上面的和与第三个字相加是： \begin{aligned} &1011101110110101\\ &\frac{1000111100001100}{0100101011000010} \end{aligned}※ 最后一次加法有溢出它要被回卷。因此将该和$0100101011000010$求反码的结果是：$1011010100111101$，这变为了检验和。在接收方，全部的4个比特字（包括检验和）加在一起。如果该分组中没有引入差错，则显然在接收方处该和将是$1111111111111111$.如果这些比特之一是0，那么我们就知道分组中已经出现了差错。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机网络——自顶向下方法》运输层——多路复用与多路分解]]></title>
    <url>%2F2020%2F02%2F19%2F%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[多路复用与多路分解 运输层的多路复用和多路分解，就是将由网络提供的主机到主机的交付服务延伸到为运行在主机上的应用程序提供进程到进程的交付服务。在目的主机，运输层从紧邻其下的网络层接收报文段。运输层负责将这些报文段中的数据交付给在主机上运行的适当应用程序进程。一个进程有一个或多个套接字（socket）,它相当于从网络向进程传递数据和从进程向网络传递数据的门户。因此，在接收主机中的运输层实际上并没有直接将数据交付给进程，而是将进程交给了一个中间套接字。由于在任意时刻，在接收主机上可能有不止一个套接字，所以每个套接字都有唯一的标识符。标识符的具体格式取决于它是UDP还是TCP。每个运输层报文段中具有几个字段。在接收端，运输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字。将运输层报文段中的数据交付到正确的套接字的工作称为多路分解。在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（在以后用于分解）从而生成报文段，然后将报文段传递到网络层，所有这些工作称为多路复用。理解了多路复用和多路分解的作用后，我们将看它们在主机中实际是怎样工作的。运输层多路复用要求：1. 套接字有唯一标识符；2. 每个报文段有特殊字段来知识该报文段所要交付到的套接字。这些特使的字段是源端口号和目的端口号。端口号是一个十六比特的数，范围在0~65535之间，0~1023为周知端口号，是受限制的。现在我们清楚了运输层是怎样实现分解服务的呢：在主机上，每个套接字能够分配一个端口号，当报文段到达该主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入其所连接的进程。 无连接的多路复用与多路分解主机上运行的Python程序通过clientSocket = socket(socket.AF_INEF, socket.SOCK_DGRAM)创建了一个UDP套接字，运输层自动的为该套接字分配一个端口号，另外一种方法是我们通过bind()方法为套接字关联一个特定的端口号（如19157），`clientSocket.bind(‘ ‘ , 19157)。通常，应用程序的客户让运输层自动地分配端口号，而服务器则分配一个特定的端口号。一个UDP套接字是由一个二元组来表示的，该二元组包含一个目的IP和一个目的端口号。 面向连接的多路复用与多路分解TCP套接字和UDP套接字之间一个细微的差别就是TCP套接字是由一个四元组$(源ip, 源端口， 目的IP, 目的端口)$来标识的。这样，当一个TCP报文段从网络到达一台主机时，该主机使用全部4个值来将报文段定向分解到相应的套接字。特别与UDP不同的是，两个具有不同源IP或端口号的到达TCP报文段将被定向到两个不同的套接字，除非TCP报文段携带了初始创建连接的请求。考虑之前的编程实例： TCP服务器应用程序有一个“welcome socket”,它在13000端口上等待来自TCP客户的连接建立请求； TCP客户创建一个套接字，并发送一个连接建立请求报文段clientSocket = socket(AF_INET, SOCKET_STREAM)clientSocket.connect((serverName, 13000)) 一条连接建立请求只不过是一个目的端口号为13000，TCP首部的特定“连接建立位” 置位的TCP报文段。这个报文段也包含一个客户选择的端口号； 当运行服务器主机的计算机的主机操作系统接收到具有目的端口号13000的入连接请求报文后，它就定位服务器进程，该进程正在端口号13000等待接受连接。该服务器进程则创建一个新的套接字：connectionSocket, addr = serverSocket.accept( ) 该服务器的运输层还注意到连接请求报文段重点的下列4个值：1. 报文段中的源端口号； 2. 源主机IP地址； 3. 该报文段中的目的端口号； 4. 自身IP地址。随着TCP连接完成，客户和服务器边可相互发送数据了。 服务器主机可以支持很多并行的TCP套接字，每个套接字与一个进程相联系，并由其四元组来标识每个套接字。当一个TCP报文段到达主机时，所有4个字段被用来将报文段定向到相应的套接字。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机网络——自顶向下方法》运输层——概述]]></title>
    <url>%2F2020%2F02%2F19%2F%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[概述和运输层服务 运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信，通过逻辑通信，运行不同进程的主机好像直接相连一样。运输层协议在端系统中而不是在路由器中实现。在发送端，运输层将从发送应用程序接收到的报文转换成运输层分组，用因特网术语来讲该分组称为运输层报文段。实现的方法是将应用报文划分为较小的快，并为每块加上运输层首部以生成运输层报文段。然后，在发送端系统中，运输层将这些报文段传递给网络层，网络层将其封装为网络层分组（数据报）并向目的地发送。网络路由器仅作用于该数据报的网络层字段；即它们不检查封装在该数据报的运输层报文段的字段。 运输层和网络层的关系网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信。运输层协议之工作在端系统中。在端系统中，运输层协议将来自应用进程的报文移动到网络边缘（即网络层），反过来也一样，但对有关这些报文在网络核心如何移动的不做任何规定。事实上，中间路由器既不做处理也不识别运输层加载应用层报文的任何信息。运输层能够楼提供的服务常常受限于底层网络层协议的服务模型。如果网络层协议无法为主机之间发送的运输层报文段提供时延或带宽保证的话，运输层协议也就无法为进程之间发送的应用程序报文提供时延或带宽保证。然而，即使底层网络协议不能再网络层提供相应的服务，运输层协议也能提供某些服务。例如，技术底层的网络协议是不可靠的，也就是说，网络层协议会使分组丢失、篡改和冗余，运输层协议也能够为应用程序提供可靠的数据传输服务。 因特网运输层概述为了简化术语，在因特网有关环境中，我们将运输层分组称为报文段（segment）,称网络层分组为数据报。因特网网络层协议有一个名叫IP，即网际协议。IP为主机之间提供了逻辑通信。IP的服务模型是尽力而为交付服务，因此IP被称为不可靠服务。UDP和TCP最基本的责任是，将两个端系统IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。将主机间交付扩展到进程间交付被称为运输层的多路复用与多路分解，UDP和TCP还可以通过在其报文段首部中包括差错检查字段而提供完整性检查。进程到进程的数据交付和差错检查时两种最低限度的运输层服务，也是UDP所能提供的仅有的两种服务。另一方方面，TCP为应用程序提供了集附加服务。首先它提供了可靠数据传输，同时TCP还提供了拥塞控制。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机网络——自顶向下方法》应用层——socket编程]]></title>
    <url>%2F2020%2F02%2F19%2F%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94socket%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[TCP套接字编程 典型的网络应用是由一对程序组成的（客户程序和服务器程序），他们位于两个不同的端系统中。当运行这两个程序时，创建了一个客户进程和一个服务器进程，同时它们通过从套接字读出和写入数据彼此进行通信。网络应用程序有两类。一类是实现在协议标准中定义的操作；另一类网络应用程序是专用的网络应用程序，这种情况下程序的应用层协议并没有公开发布在某RFC中或者其他地方。在研发阶段，开发者必须最先做的一个决定是：程序是运行在TCP上还是运行在UDP上。 UDP套接字编程运行在不同的机器上的进程彼此通过向进程发送报文来进行通信。进程好比是一座房子，进程的套接字就好比是一扇门。应用程序位于房子中门的一侧；运输层位于该门朝外的另一侧。当使用UDP时，发送进程为分组附上目的地址是由目的主机IP和目的地套接字端口号组成的。同时，发送方的源地址也是由源主机IP和端口号组成的，该地址也要附在分组上（由底层操作系统完成）。 示例 client.py 123456789from socket import *serverName = '192.168.0.5'serverPort = 12000clientSocket = socket(AF_INET, SOCK_DGRAM)message = input("请输入一串小写字母:")clientSocket.sendto(message.encode(), (serverName, serverPort))modifiedMessage, serverAddress = clientSocket.recvfrom(2048)print(modifiedMessage.decode())clientSocket.close() server.py123456789from socket import *serverPort = 12000serverSocket = socket(AF_INET, SOCK_DGRAM)serverSocket.bind(('', serverPort))print("服务器准备就绪:")while True: message, clientAddress = serverSocket.recvfrom(2048) modifiedMessage = message.upper() serverSocket.sendto(modifiedMessage, clientAddress) TCP套接字编程与UDP不同的是，TCP是一个面向连接的协议。则意味着在客户和服务器能够开始互相发送数据之前，他们先要握手和创建一个TCP连接。TCP连接的一端与客户套接字相联系另一端与服务器套接字相联系。当创建TCP连接时，我们将其与客户套接字地址和服务器套接字地址关联起来。使用创建的TCP连接，当一侧要向另一侧发送数据时，它只需经过其套接字将数据丢给TCP连接。随着服务器进程的运行，客户程序能够向服务器发起一个TCP连接。这是由客户程序通过创建一个TCP套接字完成的。当客户生成其TCP套接字时，它指定了服务中的欢迎套接字地址，即服务器主机IP地址及其套接字的端口号。生成套接字后，该客户发起一个三次握手并创建与服务器的一个TCP连接。发生在运输层的三次握手对于客户和服务器时完全透明的。 示例 client.py 123456789from socket import *serverName = '192.168.0.5'serverPort = 13000clientSocket = socket(AF_INET, SOCK_STREAM)clientSocket.connect((serverName, serverPort))message = input("请输入一段小写字母:")clientSocket.send(message.encode())modifiedMessage = clientSocket.recv(1024)print(modifiedMessage.decode()) server.py 1234567891011from socket import *serverPort = 13000serverSocket = socket(AF_INET, SOCK_STREAM)serverSocket.bind(("", serverPort))serverSocket.listen(1)while True: connectionSocket, address = serverSocket.accept() message = connectionSocket.recv(1024) modifiedMessage = message.upper() connectionSocket.send(modifiedMessage) connectionSocket.close()]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机网络——自顶向下方法》应用层——P2P应用]]></title>
    <url>%2F2020%2F02%2F19%2F%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94P2P%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[P2P应用 使用客户-服务器体系结构，极大的依赖总是打开的基础设施服务器，而使用P2P应用对总是打开的基础设施服务器有最小的（或者没有）依赖。与之相反，成对间歇连接的主机（对等方）彼此通信，这些对等方不为服务提供商所拥有，而是收用户控制的计算机。 BitTorrentBitTorrent是一种用于文件分发的流行P2P协议。用BitTorrent的术语来讲，参与一个特定文件分发的所有对等方的集合被称为一个洪流。在一个洪流中对等方彼此下载等长度的文件块，典型的长度为256KB.当一个对等方首次加入一个洪流时，他没有块。随着时间的流逝，他积累了越来越多的快，当他下载块时，也为其他的对等方上传了多个块。对等方获取到完整的文件后可以继续留在洪流中或者选择离开。同时，任何对等方也能够在任何具有块子集的时就离开洪流，并在以后重新加入。BitTorrent是一个相当复杂的协议，下面是他的一些重要的机制和内部细节：每个洪流具有一个基础设施结点，称为追踪器（tracker）.当一个追踪器加入到洪流中时他向追踪器注册自己，并周期性的通知追踪器告知自己仍在洪流中。当一个新的对等体加入时，追踪器随机地从参与对等体的集合中选择对等体的一个自己，并将这些对等体的IP发送给新加入的对等体。新加入的对等体持有这张IP表并试图与表上所有的对等体建立TCP连接。我们将成功创建TCP连接的对等方为邻近对等方。在任何时刻，对等体具有文件块的子集并知道它的邻居具有哪些块，利用这些信息将作出两个重要的决定：向邻居请求哪些块？向哪些向他请求的邻居发送块？ 在请求发送的过程中，Alice使用的是最稀缺块优先的技术，使用这种技术能够使最稀缺块更为迅速的重新分发，其目标是均衡每个块在洪流中的副本数量； 为了决定对等体响应哪个请求，BitTorrent使用了一种对换算法。基本思想是：根据当前能够以最高速率向其提供数据的邻居给出优先权，一般确定四个最高速率流入的邻居，没10秒钟重新计算速率并修改这4个对等方集合。重要的是，每过30秒，也要随机的选择另外一个邻居并向其发送块。P2P架构P2P架构主要有三种方式：中央目录、全分布和层次式。 中央目录：在这种方式中使用一个中央服务器作为中央目录，利用中央目录记录注册对等体的IP和相关的内容。显然，这种方式存在的问题有单点失败、服务器的性能影响和作为中央服务器的司法责任等。 全分布：这种方式在2000年左右提出，该方式中没有中央服务器，而是将请求泛洪给所有的对等体，系统具备对讯问请求的回答，网络设计为覆盖网。同时，为了防止网络上的请求泛滥，限制了查询距离为7跳。这种方式的优点是网络负载均衡，缺点是搜索范围引起的成本问题和搜索时间问题。 层次式：这种方式结合了全分布和中央目录。架构中设计有超级对等体和其他对等体，其中，其他对等体需要向超级对等体进行注册。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机网络——自顶向下方法》应用层——DNS]]></title>
    <url>%2F2020%2F02%2F19%2F%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94DNS%2F</url>
    <content type="text"><![CDATA[DNS:因特网的目录服务 因特网上的主机和人类一样，可以使用多种方式进行标识。主机的一种标识方法是用它的主机名（如cnn.com）,然而，主机名几乎没有提供主机在因特网中的位置信息，由于这些原因主机也可以使用所谓的IP地址进行标识。IP地址由4个字节组成，并且有着严格的层次结构。其中每个字节都被句点隔开，表示了0~255的十进制数字，具有层次结构是因为从左到右扫描IP地址时，我们能够得到越来越具体的关于主机位于因特网何处的信息。 DNS提供的服务域名系统（DNS）提供了主机名到IP地址转换的目录服务。DNS是： 一个由分层的DNS服务器实现的分布式数据库； 一个使得主机能够查询分布式数据库的应用层协议。DNS协议运行在UDP之上，使用53号端口。DNS通常是其他应用层协议所使用的，包括HTTP,SMTP和FTP,将用户提供的主机名解析为IP地址。下面是应用浏览器请求URL时的一个转换过程： 同一台用户主机上运行着DNS应用的客户端； 浏览器从上述URL中抽出主机名，并将主机名传给DNS应用的客户端； DNS客户想DNS服务器发送一个包含主机名的请求； DNS客户最终会受到一份回答报文，其中包含有对应于该主机名的IP地址； 一旦浏览器接收到来自DNS的该IP地址，它能够向位于该IP地址80端口的HTTP服务器发起一个TCP连接。通过上面的这个过程我们也能够看到DNS给使用它的因特网应用带来了额外的时延。除了主机名到IP地址的转换外，DNS还提供了一些重要的服务： 主机别名 邮件服务器别名 负载分配 DNS工作机理概述如果运行在用户主机上的某些应用程序需要将主机名转换为IP地址，这些应用程序将调用DNS的客户端，并指明需要被转换的主机名（在很多基于UNIX的机器上，进行这种转换需要调用函数gethostname（））。用户主机上的DNS接收到后，向网络红发送一个DNS查询报文。所有的DNS请求和回答报文使用UDP数据报经端口53发送。为什么DNS不采用集中式数据库？主要是因为这种设计包含以下问题： 单点故障 局部流量过大 远距离延迟 维护因此DNS采用的分布式的设计方案：[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传分布式、层次数据库大致来说，有三种类型的DNS服务器：根DNS服务器、顶级DNS服务器和权威DNS服务器。还有另外一类重要的DNS，称为本地DNS服务器，每个ISP都有一台本地DNS服务器。当主机发出DNS请求时，该请求被发往本地DNS服务器，它起着代理的作用，并将请求转发到DNS层次服务器中。域名解析是通过迭代加递归的方式进行的。DNS缓存DNS缓存是DNS系统一个非常重要的特色，是为了改善实验性能并减少在因特网上到处传输DNS报文而采用的技术。DNS记录与报文共同实现DNS分布式数据库的所有服务器存储了资源记录（RR），RR提供了主机名到IP地址的映射。每个DNS回答报文包含了一套或者多条资源记录。资源记录是一个包含了下列字段的4元组：(Name, Value, Type, TTL)TTL是该记录的生存时间，他决定了资源记录应当从缓存中删除的时间。Name和Value的值取决于Type： Type = A , 则Name是主机名，Value是主机名对应的IP地址；因此，一条类型为A的资源记录提供了标准的主机名到IP地址的映射； Type = NS，则Name是个域，Value是个知道如何获得该域中主机IP地址的权威DNS服务器主机名； Type = CNAME，则Value是别名为Name的主机名对应的规范主机名； Type = MX,Value是个别名为Name的邮件服务器的规范主机名。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机网络——自顶向下方法》应用层——Email]]></title>
    <url>%2F2020%2F02%2F19%2F%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94Email%2F</url>
    <content type="text"><![CDATA[因特网中的电子邮件 与普通的邮件相同，电子邮件是一种一步通信媒介。邮件系统主要有3个主要的组成部分：用户代理、邮件服务器和简单邮件传输协议（SMTP）.邮件服务器形成了电子邮件体系结构的核心。每个接收方在其中的某个邮件服务器上有一个邮箱。一个典型的邮件发送过程是：从发送方的用户代理开始，传输到接收方的邮件服务器，然后在这里被分发到接收方的邮箱中。当某个人需要从邮箱中取走报文的时，包含他邮箱的邮件服务器对其进行鉴别。同时，发送方也要能够处理接收方邮件服务器的故障。如果发送方的服务器不能将邮件交付给接收方的服务器，发送方的邮件服务器的报文队列中保持并在以后尝试再次发送，如果几天后仍然不行就以为电子邮件的形式通知发送发。SMTP是因特网电子邮件中主要的应用层协议，依靠TCP提供可靠数据传输，从发送方的邮件服务器向接收方的邮件服务器发送邮件。 SMTPSMTP用于从发送方的服务器发送报文到接收方的服务器。SMTP一般不适用中间邮件服务器发送邮件，因此邮件并不在中间的某个邮件服务器上存留。RFC 5321给出了SMTP的定义。 与HTTP对比两个协议都是用于从一台主机向另一台主机传送文件，当进行文件传输时二者都是使用持续连接，这是两者的一些共同特征。然而，这两个协议也有一些重要的区别：HTTP是一个拉协议，TCP连接是由想接收文件的机器发起的；SMTP是一个推协议，TCP连接是由发送该文件的机器发起的。第二个区别是SMTP要求报文使用7比特ASCII码格式，HTTP数据则不受这种限制。第三个重要的区别是在处理挺尸包含文本和图形的文档，HTTP把每个对象封装到自己的HTTP响应报文中，而SMTP则把所有的报文对象放在一个报文之中。 邮件报文格式和MIME当一个人给另一个人发送电子邮件时，一个环境信息的首部位于报文体的前面，这些环境信息包括在一系列的首部行中，由RFC 5322定义，首部行和报文体用空行进行分隔。这些首部行和SMTP命令是不同的，命令是SMTP握手协议个一部分，而本节的首部行是邮件 报文自身的一部分。 邮件访问协议对于接收方，如何通过运行本地PC上的用户代理来获取位于他的某ISP邮件服务器上的邮件？首先必须明确的是接收方的用户代理不能使用SMTP取回报文，因为取报文是一个拉操作而SMTP是一个推协议。因此，通过引入一个特殊的邮件访问协议来解决这个难题，该协议将邮件接收方的服务器上的报文传送给他的本地PC.目前有一些流行的邮件访问协议，包括有第三版的邮局协议（POP3）,因特网邮件访问协议（IMAP） POP3POP3由于RFC 1913进行定义，该协议非常简单，因此功能也相当有限。当代理带来了一个到邮件服务器端口110上的TCP连接收，POP3就开始工作了。POP3按照上个阶段进行工作：特许，事务处理以及更新。同时，POP3服务器并不在POP3会话过程中携带状态信息，这种不包括状态信息大大简化了POP3服务的实现。 IMAPPOP3协议并没有给用户提供任何创建远程文件夹并为报文自拍文件夹的方法。为了解决这个问题和其他的一些问题，由RFC 3501定义的邮件访问协议IMAP应运而生。IMAP服务器把每个报文与一个文件夹联系起来，当报文第一次到达服务器时，它与收件人的INBOX文件夹相关联。值的注意的是，IMAP服务器维护了IMAP会话的用户状态信息。IMAP的另一个非常重要的特性就是它具有允许用户代理获取报文组件的命令。 基于Web的电子邮件现在，越来越多的人用户使用web浏览器手法电子邮件，使用这种服务，用户代理就是普通的浏览器，用户和他的远程邮箱通信则是通过HTTP.]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机网络——自顶向下方法》应用层——文件传输协议：FTP]]></title>
    <url>%2F2020%2F02%2F19%2F%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%EF%BC%9AFTP%2F</url>
    <content type="text"><![CDATA[文件传输协议：FTP 典型的FTP会话中，用户坐在一台本地主机前面，向一台远程主机传输/接收文件，为了使用户能够访问他的远程账户，用户必须提供一个用户标识和口令。HTTP和FTP都是文件传输协议，并且有很多的共同特点，然而这两个应用层协议也有一些重要的区别，之中最显著的就是FTP使用了两个并行的TCP连接来传输文件，一个是控制连接，一个是数据连接。控制连接用于在两台主机之间传输控制信息，如用户标识，口令，一些其他命令等；数据连接用于发发送实际文件。因此，我们称FTP的控制信息是带外传送的，而HTTP协议是在传输文件的同一个TCP连接中发送请求和响应行首部的，因此，HTTP也可以说是带内发送控制信息的。用户主机与远程主机开始一个FTP会话时，FTP客户端首先在服务器21号端口与服务器端发起一个用于控制的TCP连接。当FTP的服务器端从该连接上接收到一个文件传输命令后（无论是向还是来自远程主机），就发起一个到客户端的TCP数据连接。FTP在该数据连接上准确的传送一个文件，然后关闭该连接，在同一个会话期间，如果用户还需要传输另一个文件，FTP则打开另一个新的数据连接。因此，对于FTP传输而言，控制连接贯穿了整个会话，但是会话期间的每一次新的文件传输都需要建立一个新的数据连接。FTP服务器必须在整个会话期间保留用户的状态，而对每个进行中的用户会话的状态信息进行追踪大大限制了FTP同时维持的会话总数。 FTP命令与回答FTP命令和回答都是以7比特的ASCII格式在控制连接上传送的，每个命令由4个大写的ASCII字符组成（有些具有可选参数），常见命令如下： USER username PASS password LIST :用于请求服务器传送回当前远程目录中的所有文件列表（文件列表是新的数据连接传送的）； RETR filename : 用于从远程主机当前目录检索（即get）文件； STOR filename : 用于远程主机当前目录存放文件；每个命令都对应着一个Fong服务器发向客户的回答，回答是一个3未数字加上可选信息，常见的回答如下： 331 Username OK, password required 125 Data connection already open; transfer starting 425 Can’t open data connection 452 Error writing file]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机网络——自顶向下方法》应用层——Web和HTTP]]></title>
    <url>%2F2020%2F02%2F19%2F%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94Web%E5%92%8CHTTP%2F</url>
    <content type="text"><![CDATA[Web和HTTP 20世纪90年代初期，一个新型应用即万维网登上了舞台，Web是一个引起公众注意的因特网应用，它极大的改变了人们与工作环境内外交流的方式。 HTTP概况Web 的应用层协议是超文本传输协议（HTTP）,它是Web的核心 。HTTP由两个程序实现：一个客户程序和一个服务器程序，二者运行在不同的端系统中，通过交换HTTP报文进行会话。web页面由对象组成，一个对象知识一个文件，多数web页面含有一个HTML基本文件，HTML基本统建通过对象的URL地址引用页面中的其他对象。Web服务器（如Apache）实现了HTTP服务端，用于存储web对象，每个对象由URL寻址。HTTP定义了web客户想web服务器请求web页面的方式，以及服务器向客户传送web页面的方式。HTTP使用TCP作为它的支撑运输协议，HTTP使用TCP作为它的支撑晕乎协议。HTTP客户首先发起一个与服务器的TCP连接。一旦连接建立，gauge浏览器和服务器进程可以通过套接字接口访问TCP。客户端的套接字接口是客户进程与TCP连接之间的们，这服务器端的套接字接口则是服务器进程与TCP连接之间的们。类似地，服务器从他的套接字接口接收HTTP请求报文向它的套接字接口发送HTTP报文。服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息，所以HTTP是一个无状态协议，web服务器总是打开的，具有一个固定的IP地址，服务于可能来自百万计的不同浏览器请求。 非持续连接和持续连接根据每个请求/响应对是经过一个 单独 的TCP连接发送，还是所有的请求及其响应经相同 的TCP连接发送，我们可以称该应用程序为使用非持续连接和持续连接.两种方式主要在往返时间（RTT）上存在区别。 HTTP报文格式HTTP请求报文HTTP请求报文的第一行叫做请求航，后继叫做首部行。请求行有3个字段：方法字段、URL字段和HTTP版本字段。方法字段可以取几种不同的值，包括GET、POST、HEAD、PUT和DELETEI(绝大部分使用GET方法) HTTP响应报文响应报文有三个部分：状态行、6个首部行，然后是实体体.状态行有三字段：协议版本字段、状态码和响应的状态信息. 首部行中:connection告诉客户，发送完报文后该TCP是否关闭；Date:服务器产生并发送该响应报文的时间;……;;Last-Modified:首部行对既可能在本地客户也可能在网络缓存服务器上的对象缓存来说非常重要；…… 下面是一些常见的状态码和他们对应的短语： 200 OK ：请求成功，信息在返回的响应报文中； 301 Moved Permanently : 请求的对象已经被永久转移了，新的URL定义在响应报文的Location:首部行中。客户软件将自动获取新的URL； 400 Bad Request:通用差错代码，指示带请求不能被服务器理解； 404 Not Found:被请求的文档不在服务器上； 505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本。 用户与服务器的交互：cookie我们知道HTTP服务器是无状态的，这简化了服务器的设计，然而web站点通常希望能够识别用户（可能是因为服务器希望限制用户的访问，或者因为它希望把内容和用户身份关联起来），为此，HTTP使用了cookiecookie技术有四个组件：1. 在HTTP响应报文中的一个cookie首部行；2. 在HTTP请求报文中的一个cookie首部行；3. 用户的端系统中保留有一个cookie文件，并由用户的浏览器进行管理；4. 位于web站点的一个后端数据库。 Web缓存Web缓存也叫代理服务器它是能够代表初始Web服务器来满足HTTP请求的网络实体，Web缓存器有自己的磁盘存储空间，并保存最近请求过的对象副本。Web缓存器是服务器同时又是客户，通常由ISP购买安装。在因特网上部署Web缓存器有两个原因： web缓存器可以大大减少对客户请求的响应时间； web缓存器可以大大减少一个机构的接入链路到因特网的通信量。 条件GET方法尽管高速缓存器能减少用户感受到的响应时间，但是引入了一个新的问题，即存放在缓存器中的对象副本可能是陈旧的。辛运的是，HTTP协议有一种机制，允许缓存器证明它的对象是最新的，这种机制就是条件GET方法（由于缓存器存储对象时也存储了最后修改日期，该机制主要就是通过检查If-Modified-Since和Last-Modified是否相等来判断是否被修改过）。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机网络——自顶向下方法》应用层——应用层协议原理]]></title>
    <url>%2F2020%2F02%2F19%2F%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[应用层协议原理 网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序。研发新的应用程序时需要编写将在多态端系统上运行的软件，不需要写在网网络和兴设备，例如路由器或者链路层交换机上运行的软件，网络的核心设备并不在应用层上起作用，而仅在较低层起作用，特别是位于网络层及下面的层次。 网络应用程序体系结构 客户服务器体系结构：在这种体系结构中有一个总是打开的诸暨称为服务器 ，它副服务于来自许多其他称为客户 的主机的请求，这种体系结构另一个特征就是服务器具有固定的，周知的地址称为IP地址 ，因此客户总是能够通过向该服务器的IP地址发送分组来与其联系。 P2P体系结构：对于位于数据中心的服务器有最小的（或者没有）依赖，应用程序在间断连接的主机对之间直接通信，这些主机被称为 对等方 。P2P体系结构中最引人入胜的特征之一是他们的自扩展性。 进程通信客户和服务器进程在操作系统的术语中，进行通信的实际上是进程而不是程序，当进程运行在相同的端系统上时，他们使用进程间通信机制相互通信，而在不同的端系统上的进程，通过跨越计算机网络交换报文而相互通信。网络引用程序由成对的进程组成，这些进程通过网络互相发送报文。 进程与计算机网络之间的接口多数引用程序由通信进程对组成，没对中的两个进程互相发送报文。进程通过一个套接字的软件接口向网络发送报文和从网络接收报文 （如果将进程类比于一座房子，而它的套接字可以类比于它的门） ，socket 起到管道的作用，不同的进程需要创建不同的socket。套接字是同一台主机内应用层与运输层之间的接口，由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的 应用程序编程接口 。应用程序开发者对于运输层的控制仅限于：1.选择运输层协议；2.设定一个运输层参数。 进程寻址在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个地址。为了标识该接收进程，需要定义两种信息：1.主机的地址；2.定义在目的主机中的接收进程的标识符。在因特网中，主机由IP地址标识。除了知道报文送往目的地的主机地址外，发送进程还必须指定运行在接收主机上的接收进程（更具体的说，接收套接字）,目的地端口号用于这个目的。 可供应用程序使用的运输服务当开发应用时，必须选择一种可用的运输层协议。应用层为了实现目标需要根据传输层提供哪些服务支持。大体上从四个方面对应用程序要求进行分类：可靠数据传输，吞吐量，定时和安全性： 可靠数据传输：分组在计算机网络中可能丢失，而像电子邮件等一些应用数据丢失可能会造成严重的后果。因此，为了支持这些应用，必须做一些工作以确保由应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端。如果一个协议提供了这样的确保数据交付服务就认为提供了可靠数据传输; 吞吐量：发送进程能够像接收进程交付比特的速率。具有吞吐量要求的应用程序称为带宽敏感的应用; 定时：定时保证能够以多种形式实现，一个保证例子如：发送方注入套接字的每个比特到达接收方的套接字不迟于100ms。这种服务将对交互式实时应用程序有吸引力。 安全性：运输程序能够为应用程序提供一种或多种安全性服务。运输层提供除了机密性，数据网整性和端点鉴别等服务。 因特网提供的运输服务因特网为应用程序提供两个运输层协议，即UDP和TCP,下表显示了某些应用程序的服务要求： 应用 数据丢失 带宽 时间敏感 文件传输 不能丢失 弹性 不 电子邮件 不能丢失 弹性 不 web文档 不能丢失 弹性 不 因特网电话/视频会议 容忍丢失 音频（几kbps~1Mbps）视频（10几kbps~5Mbps） 是，100ms 存储音频、视频 容忍丢失 同上 是，几秒 交互式游戏 容忍丢失 几kbps~10kbps 是100ms 即时通讯 不能丢失 弹性 是和不是 网络传输协议服务 TCP UDP 可靠 不可靠 提供流控制 不提供 提供拥塞控制 不提供 面向连接（先握手） 非连接 不提供定时服务，最小宽带保障，不提供安全服务 不提供定时服务，最小宽带保障，不提供安全服务 关于安全性TCP和UDP在设计之初并没有考虑到安全性的问题，也就是说发送进程传进套接字的数据，与经网络传送到目的进程的数据相同。现在为了改进在应用层和传输层增加了安全套接字层（SSL）,用SSL加强后的TCP提供了关键的进程到进程的安全性服务，包括加密，数据完整性和端点鉴别。（严格来讲，SSL属于应用层，SSL有它自己的套接字API,类似于传统的TCP套接字API）. 流行的应用及其应用层和支撑的运输层协议 应用 应用层协议 支撑的运输协议 电子邮件 SMTP TCP 远程终端访问 Telnet TCP Web HTTP TCP 文件传输 FTP TCP 流式多媒体 HTTP TCP 因特网电话 SIP、RTP或者专用的 UDP或者TCP 应用层协议应用层协议定义了运行在不同的端系统上的应用程序如何相互传递报文，特别是应用程序定义了： 交换的报文类型，例如请求报文和响应报文； 各种报文类型的语法； 字段的语义，即这些字段包含的信息的含义； 一个进程何时以及如何发送报文，对报文进行响应规则。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机网络——自顶向下方法》计算机网络和因特网]]></title>
    <url>%2F2020%2F02%2F19%2F%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91%2F</url>
    <content type="text"><![CDATA[计算机网络和因特网 什么是因特网具体构成描述 桌面PC,工作站等所有的这些计算设备称为主机或者端系统； 端系统通过通信链路和分组交换机连接到一起。通信链路由不同的物理媒体组成，包括电缆，光纤等，不同的链路以不同的传输速率（bit/s或bps）传输数据； 因特网部件都要运行一系列的协议，协议控制因特网中信息的接收和发送；其中TCP和IP是因特网中最为重要的两个协议，IP协议定义了在路由器和端系统之间发送和接收分组的格式。 服务描述 与因特网相连的端系统提供了一个API,该API规定了运行在一个端系上的软件请求因特网基础设施向运行在另一个端系统上的特定目的地软件交付数据的方式。因特网API是一套发送软件必须遵循的规则集合，因此因特网能够将数据交付给目的地。 什么是协议 在因特网中，凡是涉及到两个或多个远程通信实体的所有活动都受到协议的制约； 一个协议定义了在两个或者多个通信实体之间交换报文格式和次序，以及报文发送和接收一条报文或者其他事件采取的动作。 网络边缘网络核心 网络核心，即由互联因特网端系统的分组交换机和链路构成的网状网络； 存储转发机制是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组，在这个过程中产生的时延称为存储转发时延； 排队时延，如果到达的分组需要传输到某条链路，但发现该链路正忙于传输其他的分组，该到达分组必须在该输出缓存中等待，因此分组要承受输出缓存的排队时延； 因为缓存空间的大小是有限的，就一个到达的分组可能发现该缓存已经被其他等待传输的分组完全充满了，在此情况下将出现丢包； 转发表，用于将目的地址映射成输出链路； 分组交换网中的时延、丢包和吞吐量分组交换网中的时延概述 分组从一台主机出发，通过一些列的路由器传输，在另一台主机红结束它的历程，该分组在沿途的每个结点经受了几种不同类型的时延，其中最重要的是结点处理时延、排队时延、传输时延和传播时延，这些时延加起来就是结点总时延； 处理时延，检查分组首部和决定将该分组导向何处所需的时间是处理时延的一部分，同时处理时延也能包含其他因素，如检查比特级差错所需要的时间，高速路由器通常是微秒或者更低的数量级； 排队时延，分组在链路上等待传输的时需要的时间，一个特定的分组的排队时延长度取决于先期到达的正在排队等到向链路传输的分组数量，实际的排队时延可以是毫秒级到微秒级的； 传输时延，是将所有的分组推向链路所需要的时间，通常在毫秒到微秒级别； 传播时延，一旦一个比特被推向链路，该比特需要向路由器B传播，从该链路的起点到路由器B传播所需要的时间是传播时延，取决于该链路的物理媒介； ※传播时延是路由器将分组推出所需要的时间，它是分组长度和链路传输速率的函数，而与两台路由器之间的距离无关 排队时延和丢包 结点时延中最复杂的就是排队时延，排队时延对于不同的分组可能是不同的，例如，是个分组同时到达空队列，第一个分组没有排队时延，而最后一个则有相对较大的排队时延，因此，通常用平均排队时延，排队时延方差和超过某些值的概率进行衡量； 实际中一条链路只有有限的容量，随着流量强度接近于1，排队实验并实际趋向于无穷大，相反，到达的分组发现满队列，路由器将丢弃该分组(这部分的详细推导见原书1.4.2节)； 一个结点的性能通常不用结点时延来描述而是根据分组丢失的概率来度量端到端的时延 端到端的时延 $d_{\text {end }-\text { end }}=N\left(d_{\text {pros }}+d_{\text {trans }}+d_{\text {prop }}\right)$，其中$d_{proc}$为每台路由器和源主机上的处理时延，每条链路的传播时延是$d_{prop}$; 计算机网络中的吞吐量 计算机网络中另一个必不可少的性能度量是端到端的吞吐量，吞吐量可有瞬间吞吐量和平均吞吐量 协议的层次及其服务模型 网络设计者以分层的方式组织协议以及实现这些协议的网络硬件； 服务模型：每层通过在该层执行某些动作或者使用直接下层的服务来提供服务； 因特网的协议栈由5个层次组成：物理层，链路层，网络层，运输层和应用层 面对攻击的网络 网络安全领域主要探讨以下问题：如何攻击计算机网络以及如何防御或者事先设计免除这样攻击的新型体系结构； 经因特网将有害程序放入计算机中，一旦恶意软件感染设备就能够干各种不正当的事情，例如删除文件，获取击键等； 恶意软件能够以病毒或蠕虫的形式扩散，病毒是一种需要某种形式的用户交互来感染设备的恶意软件，蠕虫是一种无需任何明显用户交互就能进入设备的恶意软件； 拒绝服务攻击（DoS attack）,DoS攻击使得网络、主机或者其他基础设施不能由合法用户所使用，大多数的DoS攻击属于下列的三种类型之一：弱点攻击，带宽洪泛，连接洪泛 嗅探分组 伪装成受信任的人]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大小端测试]]></title>
    <url>%2F2019%2F10%2F20%2F%E5%A4%A7%E5%B0%8F%E7%AB%AF%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[大端法小端法测试 测试程序下面的程序段使用强制类型转换来访问和打印不同程序对象的字节表示. 首先将数据类型byte_pointer定义为一个指向类型为unsinged char的对象指针，这样一个字节指针引用一个字节序列，其中每个字节都被认为是一个非负整数. 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;typedef unsigned char *byte_pointer;void show_bytes(byte_pointer start, size_t len)&#123; size_t i; for (i = 0; i &lt; len; i++) printf(" %.2x", start[i]); printf("\n");&#125;void show_int(int x)&#123; show_bytes((byte_pointer) &amp;x, sizeof(int));&#125;void show_float(float x)&#123; show_bytes((byte_pointer) &amp;x, sizeof(x));&#125;void show_pointer(void *x)&#123; show_bytes((byte_pointer) &amp;x, sizeof(void *));&#125;void test_show_bytes(int val)&#123; int ival = val; float fval = (float) ival; int *pval = &amp;ival; show_int(ival); show_float(fval); show_pointer(pval);&#125;int main()&#123; int testVal = 12345; test_show_bytes(testVal); return 0;&#125; 测试结果对于上面的程序分别在64位的windows机器和64位的Linux机器上进行编译运行，其中参数$12345$的_十六进制表示_为$0x00003039$. 64位windows系统 64位Linux系统 结果分析 对于int类型的数据，我们在windows和Linux64上都都得到了相同的结果，同时，最低有效字节$0x39$最先输出,说明它们是小端法机器； 同样地，对于float类型的数据结果也是相同的； 对于两种机器的指针值是完全不同的，说明不同的机器/操作系统使用不同的存储分配规则； 64位windows机器采用的是4字节地址，而Linux64使用的是8字节地址.]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Amdahl定律]]></title>
    <url>%2F2019%2F10%2F19%2FAmdahl%E5%AE%9A%E5%BE%8B%2F</url>
    <content type="text"><![CDATA[Amdahl定律 Gene Amdahl, 计算领域的早期先锋之一， 对提升系统的某一部分性能所带来的效果做出了简单却有见地的观察，这个观察被称为Amdahl定律（Amdahl’s law, 阿姆达尔定律）. 定律的主要思想是当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度. 若系统执行某应用程序需要的时间为 $T_{\text {old }}$ .假设系统的某部分所需的执行时间与该随时间的比例为$\alpha$,而该部分系统性能提升比例为$k$.即该部分初始所需时间为$\alpha T_{\mathrm{old}}$，现在所需时间为$\left(\alpha T_{\mathrm{old}}\right) / k$.因此，总的执行时间为： T_{\text {new }}=(1-\alpha) T_{\text {old }}+\left(\alpha T_{\text {old }}\right) / k=T_{\text {old }}[(1-\alpha)+\alpha / k]​, 由此，计算加速比$S=T_{\mathrm{old}} / T_{\mathrm{new}}$为： S=\frac{1}{(1-\alpha)+\alpha / k}. 举例，考虑这样一种情况，系统的某个部分初始耗时为$60 \%(\alpha=0.6)​$，其加速比例因子为$3（k=3）​$。则我们获得的加速比为$1 /[0.4+0.6 / 3]=1.67​$倍.虽然我们对系统的一个主要部分进行了重大改进，但是获得的系统加速比却明显小于这部分的加速比. 通过上面的例子，也可以看出Amdahl定律的主要观点——要想加速整个系统，必须提升全系统中相当大部分的速度. 现在，我们考虑Amdahl定律的一个有趣的特殊情况：$k$趋向于$\infty$时的效果.这意味着我们可以取系统的某一个部分将其加速到一个点，在这个点上，这部分花费的时间可以忽略不计，于是得到 S_{\infty}=\frac{1}{(1-\alpha)}. 举例来说，如果$60 \%$的系统能够加速到不花时间的程度，我们获取的净加速比将仍只有$1 / 0.4=2.5 \times$. Amdahl定律描述了改善任何过程的一般原则，除了可以用在加速计算机系统方面之外，它还可以用在公司试图降低制造成本。也许它在计算机世界里是最有意义的，这里我们通常把性能提升$2$倍或者更高的比列因子。这么高的比列因子只有通过优化系统的大部分组件才能获取.]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程乐趣与烦恼]]></title>
    <url>%2F2019%2F03%2F23%2F%E7%BC%96%E7%A8%8B%E4%B9%90%E8%B6%A3%E4%B8%8E%E7%83%A6%E6%81%BC%2F</url>
    <content type="text"><![CDATA[摘录自FrederickP.Brooks.Jr的《人月神话》 职业的乐趣&ensp; &ensp; 编程为什么有趣？作为回报，它的从业者期望得到什么样的快乐？首先是一种创建事物的纯粹快乐。如同小孩在玩泥巴时感到愉快一样，成年人喜欢创建事物，特别是自己进行设计。我想这种快乐是上帝创造世界的折射，一种呈现在每片独特、崭新的树叶和雪花上的喜悦。&ensp; &ensp; 其次，快乐来自于开发对其他人有用的东西。内心深处，我们期望其他人使用我们的劳动成果，并能对他们有所帮助。从这个方面，这同小孩用粘土为”爸爸办公室”捏制铅笔盒没有本质的区别。第三是整个过程体现出魔术般的力量—将相互啮合的零部件组装在一起，看到它们精妙地运行，得到预先所希望的结果。比起弹珠游戏或点唱机所具有的迷人魅力，程序化的计算机毫不逊色。&ensp; &ensp; 第四是学习的乐趣，来自于这项工作的非重复特性。人们所面临的问题，在某个或其它方面总有些不同。因而解决问题的人可以从中学习新的事物：有时是实践上的，有时是理论上的，或者兼而有之。&ensp; &ensp; 最后，乐趣还来自于工作在如此易于驾驭的介质上。程序员，就像诗人一样，几乎仅仅工作在单纯的思考中。程序员凭空地运用自己的想象，来建造自己的”城堡”。很少有这样的介质—创造的方式如此得灵活，如此得易于精炼和重建，如此得容易实现概念上的设想。（不过我们将会看到，容易驾驭的特性也有它自己的问题）然而程序毕竟同诗歌不同，它是实实在在的东西；可以移动和运行，能独立产生可见的输出；能打印结果，绘制图形，发出声音，移动支架。神话和传说中的魔术在我们的时代已变成了现实。在键盘上键入正确的咒语，屏幕会活动、变幻，显示出前所未有的或是已经存在的事物。&ensp; &ensp; 编程非常有趣，在于它不仅满足了我们内心深处进行创造的渴望，而且还愉悦了每个人内在的情感。 职业的苦恼&ensp; &ensp; 然而这个过程并不全都是喜悦。我们只有事先了解一些编程固有的烦恼，这样，当它们真的出现时，才能更加坦然地面对。&ensp; &ensp; 首先，必须追求完美。因为计算机也是以这样的方式来变戏法：如果咒语中的一个字符、一个停顿，没有与正确的形式一致，魔术就不会出现。（现实中，很少的人类活动要求完美，所以人类对它本来就不习惯。）实际上，我认为学习编程的最困难部分，是将做事的方式往追求完美的方向调整。&ensp; &ensp; 其次，是由他人来设定目标，供给资源，提供信息。编程人员很少能控制工作环境和工作目标。用管理的术语来说，个人的权威和他所承担的责任是不相配的。不过，似乎在所有的领域中，对要完成的工作，很少能提供与责任相一致的正式权威。而现实情况中，实际（相对于正式）的权威来自于每次任务的完成。&ensp; &ensp; 对于系统编程人员而言，对其他人的依赖是一件非常痛苦的事情。他依靠其他人的程序，而往往这些程序设计得并不合理，实现拙劣，发布不完整（没有源代码或测试用例），或者文档记录得很糟。所以，系统编程人员不得不花费时间去研究和修改，而它们在理想情况下本应该是可靠完整的。&ensp; &ensp; 下一个烦恼—概念性设计是有趣的，但寻找琐碎的bug却只是一项重复性的活动。伴随着创造性活动的，往往是枯燥沉闷的时间和艰苦的劳动。程序编制工作也不例外。另外，人们发现调试和查错往往是线性收敛的，或者更糟糕的是，具有二次方的复杂度。结果，测试一拖再拖，寻找最后一个错误比第一个错误将花费更多的时间。&ensp; &ensp; 最后一个苦恼，有时也是一种无奈—当投入了大量辛苦的劳动，产品在即将完成或者终于完成的时候，却已显得陈旧过时。可能是同事和竞争对手已在追逐新的、更好的构思；也许替代方案不仅仅是在构思，而且已经在安排了。&ensp; &ensp; 现实情况比上面所说的通常要好一些。当产品开发完成时，更优秀的新产品通常还不能投入使用，而仅仅是为大家谈论而另外，它同样需要数月的开发时间。事实上，只有实际需要时，才会用到最新的设想，因为所实现的系统已经能满足要求，体现了回报。&ensp; &ensp; 诚然，产品开发所基于的技术在不断地进步。一旦设计被冻结，在概念上就已经开始陈旧了。不过，实际产品需要一步一步按阶段实现。实现落后与否的判断应根据其它已有的系统，而不是未实现的概念。因此，我们所面临的挑战和任务是在现有的时间和有效的资源范围内，寻找解决实际问题的切实可行方案。&ensp; &ensp; 这，就是编程。一个许多人痛苦挣扎的焦油坑以及一种乐趣和苦恼共存的创造性活动。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
</search>
