<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数学建模论文写作]]></title>
    <url>%2F2019%2F04%2F27%2F%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[一.数学建模的关键点 模型 创造性 结果 论文 二.从论文的角度看学生存在的问题 题意吃透不足，没有抓住主要要解决的问题； 就事论事，形成数学模型的能力欠缺； 对所用的方法一知半解，不管具体的条件，套用现成的方法，导致错误； 对结果的分析不足，怎样符合实际考虑不周； 写作方面存在问题（摘要，优缺点，参考文献） 队员之间的合作精神差，孤军奋战； 三.数学建模竞赛的论文结构0.结构概述 1.标题 2.目录 3.摘要（关键词） 4.问题重述 5.符号说明 6.模型建设 7.问题一的建立与求解 8.问题二的建立与求解 9… 10.模型的总结与评价 11.参考文献 12.附录 1.标题 准确完整：准确的表达论文的内容，恰当的反映研究的问题和深度 简明扼要：题目要简洁不要过长，可以采用主副标题 清楚：清晰的反映论文的具体内容，明确研究工作的独到之处 醒目：题目要有吸引力，一目了然 ==题目最好表明研究的问题，采用的模型，求解的算法== 标题不要使用加工过的文学语言 不要使用口号式的 谨慎的使用缩略语 避免使用化学式，上下标，特殊符号，公式等 尽量不要使用“研究” e.g. 基于优化模型的蔬菜种植运输问题 基于TSP问题的图像拼接 基于改进的蚁群算法求解AGTSP碎纸片拼接复原 上面的几个例子中第三个是比较可取的，但是使用的缩略语，第一二个没有说明求解算法 2.摘要2.1.概述 摘要应该在论文的最后完成，一般至少需要准备==三个小时==进行书写; 只要要能够吸引评委的眼球。表达出全文的概貌，要点，特色，要回答题目中的全部问题 2.2. 摘要的特点 ==短==：篇幅短，字数少，一般不超过一页 ==精==：内容精，概括的文章的精华 ==完整==：指摘要能够独立成篇，方便论文检索 2.4.标准结构:==三段六句== 第一段：总体表明研究的问题和方法（最多三行） 第二段：问题一 … 最后一段：本文的创新点或者优点（==两条足矣，绝对不要出现类似添补的国内的空白这类话==） 关于每个问题的标准写法 第一句总领全段，第二句预备工作，第三句采用的模型，第四句求解的算法，第五句给出问题的结果，第六句结果分析评价 2.5. 注意事项 多一字有余，差一字不足; 篇幅不超过一页; 摘要的第一句最重要,内容包括研究的动机和存在的不足 摘要不要使用表，公式，参考文献的序号 避免使用会引起混淆的缩略语和简写 如果有多个问题提倡分段 结果应当给出具体的结果 不必要使用英文 ==评分理论值为10分，实际的分值远远大于10分== 3.关键词 是摘要的浓缩，是反应文章主题内容最重要的词，短语 数量：3—6个 关键词的遴选：从论文的题目，摘要，小标题，和结论中找，i.g.研究的问题，解决问题的方法（模型和算法），结论 4.目录 是自动生成的目录 三级目录 5. 问题重述 问题重述部分是要保持全文的完整性，要求用自己的语言将赛题重新叙述一遍，可以根据自己的理解，用自己的语言简明的说清楚背景，条件和要求 将原问题用数学语言表达出来 努力将评卷老师引导到自己的思路上来 ==绝对不是题目的完整拷贝，如果完整拷贝，那就是自杀== 参考格式 问题背景 问题提出 灵活的增加一些东西，e.g.数据 6.符号说明 论文中的每一个数学符号都要有各自的含义，习惯用表格单独说明 所有的符号第一次使用时还要说明 尽量使用英文缩写，e.g. t(time)… 符号说明用三线表展示 7.模型的假设 假设的合理性 如何假设？1.题目给的条件假设；2.从题目的要求中假设 关键性假设不能缺，假设要符合题意 不要有一大堆没用的假设 数量：3-6个 ==亮点:写出假设的理由== 8.问题一的模型建立和求解8.0总体结构概述 问题一的描述与分析 预备工作 模型的建立 模型的求解 求解结果 结果分析 8.1.问题一的描述与分析 针对赛题进行全面的解析，说明要解决的是什么问题，问题的关键是什么，解决问题的大致思路，大致步骤，是建模的必要准备 ==要点：弄清题意，梳理思路== 分析要中肯，确切，术语专业，表达简明扼要 ==亮点：做文献综述==，i.g.别人在这方面是怎么做的，在了解别人的基础上展开工作 8.2.预备工作 将建模的算法和需要的预备工作写在这里 一个预备工作一个小标题 8.3.模型的建立 ==每一篇论文都至少有一个数学== 同一个问题不要建立几个模型，但是可以从一个模型开始，逐步深化 主要的类型：优化模型，方程模型，统计模型 最佳方式：实际的问题转化为经典的模型 解决问题的方式：一般模型，特殊模型 改进方式：当求解有困难时，可以进行简化，结果不合理时，可以进行模型深化 常见的问题：==没有模型，只是凑出一个结果；或者罗列模型而且不比较好坏== 8.4.模型的求解 需要建立数学命题时，叙述要规范，论证要严密。能用定理给出的，尽量给出定理，并证明 需要说明计算方法或者算法原理，思想，依据，步骤 计算过程，篇幅大时推到放到附录 ==流程图== 结果要清晰的罗列 趋势：转化算法后软件求解 8.5.结果 题目中要回答的问题，数值结果，结论，要一一列出 结果表示:要集中，一目了然，直观，便于分析 数字结果:==精心设计漂亮的表格== 求解方案，用图示更好 8.6结果分析 目的是说明模型和结果的正确性：实践是检验真理的唯一标准 误差分析:灵敏度分析，稳定性分析，对比分析，算法的收敛性分析，算法的时间复杂度分析… 9.模型的总结与评价 四个部分：总结，优点，缺点，改进与展望 优点要突出，缺点不回避 优点从哪里找?假设合理，建模方法创新，求解特色 改进与展望：由于时间关系来不及实现，给出改进方向 推广和改进方向，不要玩弄数学用语 10.参考文献 引用时间新，水平高的杂志，（至少2015年及以后） 顺序标号 标准：==GB/T 7714-2015《信息与文献参考文献著录规则》== ==参考文献必须用软件生成==，常用的有EndNote（英文），NoteExpress（中文） 11.附录 内容:程序清单，详细公式推导，定理证明，中间结果，跟多的图表 注意事项：不要出现错误，错误的宁可不列，主要的数据正文中也要有，不怕重复 四.其他1.关于公式 全部使用mathType编辑，直接剪切，不要调整大小 另起一行并居中，公式当做一个名词，注意后面的标点符号 公式不要超过一行 2.关于流程图 Viso或者Word自带绘制 3.关于表 尽量使用三线表 4.关于图 大小一致，规范美观，一般A4并排放两张 可以使用各种图 5.关于结果展示 表格展示 图片展示 不能直接对软件进行截图 6.其他注意事项 备份 存档 写作不是一个人的事情 至少3个小时写摘要 多用图表 尽量引用高水平的论文和外文文献 7.分数分布 摘要 总体 模型 算法 结果 检验 其他 10 10 30 20 10 10 10]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>数学建模</tag>
        <tag>论文写作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy学习-2]]></title>
    <url>%2F2019%2F03%2F27%2FNumpy%E5%AD%A6%E4%B9%A0-2%2F</url>
    <content type="text"><![CDATA[直接由jupyter notebook导出 Numpy学习(2)1import numpy as np 矩阵的运算给定向量a=(0,1,2),对于向量中的每个元素乘以2 12a=np.array([0,1,2])a array([0, 1, 2]) 12*a array([0, 2, 4]) Universal Function12A=np.arange(1,16).reshape(3,5)A array([[ 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10], [11, 12, 13, 14, 15]]) 1A+1 array([[ 2, 3, 4, 5, 6], [ 7, 8, 9, 10, 11], [12, 13, 14, 15, 16]]) 1A*2 array([[ 2, 4, 6, 8, 10], [12, 14, 16, 18, 20], [22, 24, 26, 28, 30]]) 1A/2 array([[0.5, 1. , 1.5, 2. , 2.5], [3. , 3.5, 4. , 4.5, 5. ], [5.5, 6. , 6.5, 7. , 7.5]]) 1A**2 array([[ 1, 4, 9, 16, 25], [ 36, 49, 64, 81, 100], [121, 144, 169, 196, 225]], dtype=int32) 1A%2 array([[1, 0, 1, 0, 1], [0, 1, 0, 1, 0], [1, 0, 1, 0, 1]], dtype=int32) 11/A array([[1. , 0.5 , 0.33333333, 0.25 , 0.2 ], [0.16666667, 0.14285714, 0.125 , 0.11111111, 0.1 ], [0.09090909, 0.08333333, 0.07692308, 0.07142857, 0.06666667]]) 1np.abs(A) array([[ 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10], [11, 12, 13, 14, 15]]) 1np.sin(A) array([[ 0.84147098, 0.90929743, 0.14112001, -0.7568025 , -0.95892427], [-0.2794155 , 0.6569866 , 0.98935825, 0.41211849, -0.54402111], [-0.99999021, -0.53657292, 0.42016704, 0.99060736, 0.65028784]]) 1np.exp(A) array([[2.71828183e+00, 7.38905610e+00, 2.00855369e+01, 5.45981500e+01, 1.48413159e+02], [4.03428793e+02, 1.09663316e+03, 2.98095799e+03, 8.10308393e+03, 2.20264658e+04], [5.98741417e+04, 1.62754791e+05, 4.42413392e+05, 1.20260428e+06, 3.26901737e+06]]) 1np.power(3,A) array([[ 3, 9, 27, 81, 243], [ 729, 2187, 6561, 19683, 59049], [ 177147, 531441, 1594323, 4782969, 14348907]], dtype=int32) 1np.log2(A) array([[0. , 1. , 1.5849625 , 2. , 2.32192809], [2.5849625 , 2.80735492, 3. , 3.169925 , 3.32192809], [3.45943162, 3.5849625 , 3.70043972, 3.80735492, 3.9068906 ]]) 矩阵间的运算12A=np.arange(4).reshape(2,2)A array([[0, 1], [2, 3]]) 12B=np.full((2,2),10)B array([[10, 10], [10, 10]]) 1A+B array([[10, 11], [12, 13]]) 1A-B array([[-10, -9], [ -8, -7]]) 12# 对应元素的乘积A*B array([[ 0, 10], [20, 30]]) 12#对应元素之间的除法A/B array([[0. , 0.1], [0.2, 0.3]]) 12#矩阵的乘法A.dot(B) array([[10, 10], [50, 50]]) 12#矩阵的转置A.T array([[0, 2], [1, 3]]) 向量与矩阵的运算1A array([[0, 1], [2, 3]]) 12v=np.array([1,2])v array([1, 2]) 加123#向量与矩阵中的每一行相加v+A #数学中无意义 array([[1, 3], [3, 5]]) 1np.vstack([v]*A.shape[0])+A array([[1, 3], [3, 5]]) 1np.tile(v,(2,1))+A array([[1, 3], [3, 5]]) 乘法1v*A array([[0, 2], [2, 6]]) 12# 矩阵间的乘法v.dot(A) array([4, 7]) 1A.dot(v) #numpy自动的确定行向量和列向量 array([2, 8]) 矩阵的逆1A array([[0, 1], [2, 3]]) 1invA=np.linalg.inv(A) 1A.dot(invA) array([[1., 0.], [0., 1.]]) 12x=np.arange(0,16,1).reshape(2,8)x array([[ 0, 1, 2, 3, 4, 5, 6, 7], [ 8, 9, 10, 11, 12, 13, 14, 15]]) 123#求矩阵的伪逆pinvx=np.linalg.pinv(x)pinvx array([[-1.35416667e-01, 5.20833333e-02], [-1.01190476e-01, 4.16666667e-02], [-6.69642857e-02, 3.12500000e-02], [-3.27380952e-02, 2.08333333e-02], [ 1.48809524e-03, 1.04166667e-02], [ 3.57142857e-02, -1.04083409e-17], [ 6.99404762e-02, -1.04166667e-02], [ 1.04166667e-01, -2.08333333e-02]]) 1x.dot(pinvx) array([[ 1.00000000e+00, -2.49800181e-16], [ 0.00000000e+00, 1.00000000e+00]]) 聚合操作一维的聚合运算12L=np.random.random(100)L array([0.87573398, 0.67501167, 0.19874448, 0.45128579, 0.87728048, 0.3992231 , 0.04337321, 0.35165112, 0.09329798, 0.27841018, 0.89502298, 0.79592868, 0.72965371, 0.55066736, 0.39673235, 0.09025584, 0.4681407 , 0.12976291, 0.96644763, 0.37252674, 0.99482023, 0.48716849, 0.04322846, 0.357683 , 0.91251502, 0.18163644, 0.23667114, 0.51066678, 0.15199209, 0.48058338, 0.73668235, 0.68639835, 0.93008385, 0.4349003 , 0.41466393, 0.0474914 , 0.08494696, 0.05953704, 0.8110798 , 0.56379862, 0.85395394, 0.25940165, 0.01383781, 0.2305063 , 0.78717336, 0.71975633, 0.03448859, 0.30844727, 0.67978253, 0.61208165, 0.88428785, 0.85554152, 0.28244673, 0.13667229, 0.66524831, 0.58252952, 0.75194173, 0.77858238, 0.12959418, 0.50311045, 0.98024221, 0.19155677, 0.98363842, 0.77112865, 0.89358774, 0.43570674, 0.09156904, 0.64146335, 0.57384783, 0.30997722, 0.61071868, 0.05227516, 0.022356 , 0.35313323, 0.8889014 , 0.28444816, 0.70192023, 0.59703519, 0.18617025, 0.42949736, 0.53536229, 0.71035688, 0.61404413, 0.91394917, 0.7353239 , 0.42738586, 0.69434886, 0.53646667, 0.00187462, 0.12664177, 0.52950761, 0.79619012, 0.80728167, 0.68430105, 0.57447197, 0.73118737, 0.90417553, 0.37069038, 0.28074295, 0.45566072]) 1sum(L) #计算列表的和 50.26422002639282 1np.sum(L) 50.26422002639284 1np.min(L) 0.001874618596041655 1np.max(L) 0.994820231853337 二维的聚合运算123X=np.arange(16).reshape(4,4)X array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]) 1np.sum(X) 120 12#求每一列的和与每一行的和np.sum(X,axis=0) #注意此处的列上的和 array([24, 28, 32, 36]) 1np.sum(X,axis=1) array([ 6, 22, 38, 54]) 1np.prod(X) #乘积 0 1np.prod(X+1) 2004189184 12#均值np.mean(X) 7.5 12#中位数np.median(X) 7.5 12#求解百分位点np.percentile(X,100) 15.0 12#方差np.var(X) 21.25 12#标准差np.std(X) 4.6097722286464435 索引1x=np.random.normal(0,1,1000000) 1np.min(x) -4.632350126506717 1np.argmin(x) 85945 1x[np.argmin(x)] -4.632350126506717 排序和使用索引12x=np.arange(16)x array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) 123#进行乱序处理np.random.shuffle(x)x array([ 9, 15, 13, 3, 7, 10, 8, 4, 2, 6, 11, 14, 5, 0, 1, 12]) 12x.sort()x array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) 12X=np.random.randint(10,size=(4,4))X array([[9, 7, 3, 2], [1, 0, 3, 3], [6, 9, 0, 3], [0, 3, 8, 6]]) 1np.sort(X) array([[2, 3, 7, 9], [0, 1, 3, 3], [0, 3, 6, 9], [0, 3, 6, 8]]) 1np.sort(X,axis=1)#沿着列进行排序 array([[2, 3, 7, 9], [0, 1, 3, 3], [0, 3, 6, 9], [0, 3, 6, 8]]) 1np.sort(X,axis=0)#沿着行进行排序 array([[0, 0, 0, 2], [1, 3, 3, 3], [6, 7, 3, 3], [9, 9, 8, 6]]) 1x array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) 1np.random.shuffle(x) 1x array([ 0, 13, 6, 3, 10, 14, 15, 4, 11, 1, 2, 9, 12, 5, 7, 8]) 1np.argsort(x)#按照索引进行的排序 array([ 0, 9, 10, 3, 7, 13, 2, 14, 15, 11, 4, 8, 12, 1, 5, 6], dtype=int64) 1np.partition(x,3) #使用快排的partition array([ 0, 1, 2, 3, 4, 14, 15, 13, 11, 10, 6, 9, 12, 5, 7, 8]) 1np.argpartition(x,3) array([ 0, 9, 10, 3, 7, 5, 6, 1, 8, 4, 2, 11, 12, 13, 14, 15], dtype=int64) 1X array([[9, 7, 3, 2], [1, 0, 3, 3], [6, 9, 0, 3], [0, 3, 8, 6]]) 1np.argsort(X,axis=1) #返回的是索引值 array([[3, 2, 1, 0], [1, 0, 2, 3], [2, 3, 0, 1], [0, 1, 3, 2]], dtype=int64) 1np.argpartition(X,2,axis=1) array([[3, 2, 1, 0], [1, 0, 2, 3], [2, 3, 0, 1], [0, 1, 3, 2]], dtype=int64) Fancy Indexing12x=np.arange(16)x array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) 12ind=[3,4,8]x[ind] array([3, 4, 8]) 123ind=np.array([[0,2], [1,3]])x[ind] array([[0, 2], [1, 3]]) 12X=x.reshape(4,4)X array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]) 123row=np.array([0,1,2]) #存行所在的索引col=np.array([1,2,3]) #存列所在的索引X[row,col] array([ 1, 6, 11]) 1X[0,row] array([0, 1, 2]) 1X[:2,row] array([[0, 1, 2], [4, 5, 6]]) 12col=[True,False,True,True] #表示对0,2，3列感兴趣X[1:3,col] array([[ 4, 6, 7], [ 8, 10, 11]]) numpy.array的比较1x array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) 1x&lt;3 array([ True, True, True, False, False, False, False, False, False, False, False, False, False, False, False, False]) 1x==3 array([False, False, False, True, False, False, False, False, False, False, False, False, False, False, False, False]) 1X==7 array([[False, False, False, False], [False, False, False, True], [False, False, False, False], [False, False, False, False]]) 12]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程乐趣与烦恼]]></title>
    <url>%2F2019%2F03%2F23%2F%E7%BC%96%E7%A8%8B%E4%B9%90%E8%B6%A3%E4%B8%8E%E7%83%A6%E6%81%BC%2F</url>
    <content type="text"><![CDATA[摘录自FrederickP.Brooks.Jr的《人月神话》 职业的乐趣&ensp; &ensp; 编程为什么有趣？作为回报，它的从业者期望得到什么样的快乐？首先是一种创建事物的纯粹快乐。如同小孩在玩泥巴时感到愉快一样，成年人喜欢创建事物，特别是自己进行设计。我想这种快乐是上帝创造世界的折射，一种呈现在每片独特、崭新的树叶和雪花上的喜悦。&ensp; &ensp; 其次，快乐来自于开发对其他人有用的东西。内心深处，我们期望其他人使用我们的劳动成果，并能对他们有所帮助。从这个方面，这同小孩用粘土为”爸爸办公室”捏制铅笔盒没有本质的区别。第三是整个过程体现出魔术般的力量–将相互啮合的零部件组装在一起，看到它们精妙地运行，得到预先所希望的结果。比起弹珠游戏或点唱机所具有的迷人魅力，程序化的计算机毫不逊色。&ensp; &ensp; 第四是学习的乐趣，来自于这项工作的非重复特性。人们所面临的问题，在某个或其它方面总有些不同。因而解决问题的人可以从中学习新的事物：有时是实践上的，有时是理论上的，或者兼而有之。&ensp; &ensp; 最后，乐趣还来自于工作在如此易于驾驭的介质上。程序员，就像诗人一样，几乎仅仅工作在单纯的思考中。程序员凭空地运用自己的想象，来建造自己的”城堡”。很少有这样的介质–创造的方式如此得灵活，如此得易于精炼和重建，如此得容易实现概念上的设想。（不过我们将会看到，容易驾驭的特性也有它自己的问题）然而程序毕竟同诗歌不同，它是实实在在的东西；可以移动和运行，能独立产生可见的输出；能打印结果，绘制图形，发出声音，移动支架。神话和传说中的魔术在我们的时代已变成了现实。在键盘上键入正确的咒语，屏幕会活动、变幻，显示出前所未有的或是已经存在的事物。&ensp; &ensp; 编程非常有趣，在于它不仅满足了我们内心深处进行创造的渴望，而且还愉悦了每个人内在的情感。 职业的苦恼&ensp; &ensp; 然而这个过程并不全都是喜悦。我们只有事先了解一些编程固有的烦恼，这样，当它们真的出现时，才能更加坦然地面对。&ensp; &ensp; 首先，必须追求完美。因为计算机也是以这样的方式来变戏法：如果咒语中的一个字符、一个停顿，没有与正确的形式一致，魔术就不会出现。（现实中，很少的人类活动要求完美，所以人类对它本来就不习惯。）实际上，我认为学习编程的最困难部分，是将做事的方式往追求完美的方向调整。&ensp; &ensp; 其次，是由他人来设定目标，供给资源，提供信息。编程人员很少能控制工作环境和工作目标。用管理的术语来说，个人的权威和他所承担的责任是不相配的。不过，似乎在所有的领域中，对要完成的工作，很少能提供与责任相一致的正式权威。而现实情况中，实际（相对于正式）的权威来自于每次任务的完成。&ensp; &ensp; 对于系统编程人员而言，对其他人的依赖是一件非常痛苦的事情。他依靠其他人的程序，而往往这些程序设计得并不合理，实现拙劣，发布不完整（没有源代码或测试用例），或者文档记录得很糟。所以，系统编程人员不得不花费时间去研究和修改，而它们在理想情况下本应该是可靠完整的。&ensp; &ensp; 下一个烦恼–概念性设计是有趣的，但寻找琐碎的bug却只是一项重复性的活动。伴随着创造性活动的，往往是枯燥沉闷的时间和艰苦的劳动。程序编制工作也不例外。另外，人们发现调试和查错往往是线性收敛的，或者更糟糕的是，具有二次方的复杂度。结果，测试一拖再拖，寻找最后一个错误比第一个错误将花费更多的时间。&ensp; &ensp; 最后一个苦恼，有时也是一种无奈–当投入了大量辛苦的劳动，产品在即将完成或者终于完成的时候，却已显得陈旧过时。可能是同事和竞争对手已在追逐新的、更好的构思；也许替代方案不仅仅是在构思，而且已经在安排了。&ensp; &ensp; 现实情况比上面所说的通常要好一些。当产品开发完成时，更优秀的新产品通常还不能投入使用，而仅仅是为大家谈论而另外，它同样需要数月的开发时间。事实上，只有实际需要时，才会用到最新的设想，因为所实现的系统已经能满足要求，体现了回报。&ensp; &ensp; 诚然，产品开发所基于的技术在不断地进步。一旦设计被冻结，在概念上就已经开始陈旧了。不过，实际产品需要一步一步按阶段实现。实现落后与否的判断应根据其它已有的系统，而不是未实现的概念。因此，我们所面临的挑战和任务是在现有的时间和有效的资源范围内，寻找解决实际问题的切实可行方案。&ensp; &ensp; 这，就是编程。一个许多人痛苦挣扎的焦油坑以及一种乐趣和苦恼共存的创造性活动。]]></content>
      <categories>
        <category>software engineering</category>
      </categories>
      <tags>
        <tag>software engineering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy学习(1)]]></title>
    <url>%2F2019%2F03%2F23%2FNumpy%E5%AD%A6%E4%B9%A0-1%2F</url>
    <content type="text"><![CDATA[直接由jupyter notebook导出 numpy.array基础1import numpy as np 12#版本号查看np.__version__ &apos;1.15.4&apos; 12nparr=np.array([i for i in range(10)])nparr array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 12#查看nparr[5] 5 12#查看类型nparr.dtype dtype(&apos;int32&apos;) 12nparr2=np.array([1,1.0])nparr2.dtype dtype(&apos;float64&apos;) 数组与矩阵的创建1np.zeros(10) array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) 1np.zeros(10).dtype dtype(&apos;float64&apos;) 1np.zeros((3,5)) array([[0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.]]) 1np.ones(shape=(3,5)) array([[1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.]]) 12#指定值创建np.full(shape=(3,5),fill_value=123) array([[123, 123, 123, 123, 123], [123, 123, 123, 123, 123], [123, 123, 123, 123, 123]]) arange1[i for i in range(0,20,2)] [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] 1np.arange(0,20,2) array([ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18]) 1np.arange(0,1,0.2) array([0. , 0.2, 0.4, 0.6, 0.8]) 12# arange默认0开始,步长为1np.arange(10) array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) linspace1np.linspace(0,20,10)#第三个值表示在0到20截出10个值 array([ 0. , 2.22222222, 4.44444444, 6.66666667, 8.88888889, 11.11111111, 13.33333333, 15.55555556, 17.77777778, 20. ]) 1np.linspace(0,20,11) array([ 0., 2., 4., 6., 8., 10., 12., 14., 16., 18., 20.]) random1np.random.randint(0,10) 9 1np.random.randint(0,10,size=10)#区间是左闭右开 array([4, 4, 3, 1, 8, 8, 9, 0, 6, 3]) 1np.random.randint(0,10,size=[3,5]) array([[2, 8, 7, 3, 8], [6, 7, 3, 2, 8], [2, 5, 8, 5, 3]]) 123#指定随机种子np.random.seed(666)np.random.randint(0,10,size=[3,5]) array([[2, 6, 9, 4, 3], [1, 0, 8, 7, 5], [2, 5, 5, 4, 8]]) 12np.random.seed(666)np.random.randint(0,10,size=[3,5]) array([[2, 6, 9, 4, 3], [1, 0, 8, 7, 5], [2, 5, 5, 4, 8]]) 12#生成均匀的随机数np.random.random(10) array([0.73159555, 0.8578588 , 0.76741234, 0.95323137, 0.29097383, 0.84778197, 0.3497619 , 0.92389692, 0.29489453, 0.52438061]) 12#生成符合正态分布的浮点数np.random.normal(0,1,10)#均值为0方差为1 array([-0.25584759, -1.76438083, -0.94249688, -1.58045861, 0.90472662, -0.82628327, 0.82101369, 0.36712592, 1.65399586, 0.13946473]) 1np.random.normal(10,100,2) array([-111.71535503, -89.49473667]) 数组的基本操作1import numpy as np 12x=np.arange(10)x array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 12X=np.arange(15).reshape(3,5)X array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) 基本属性1x.ndim 1 1X.ndim 2 1x.shape (10,) 1X.shape (3, 5) 1x.size 10 1X.size 15 数据访问1x array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 1x[3] 3 1x[-1] 9 1X array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) 1X[1][1]#不建议使用两个方括号访问 6 1X[(0,0)] 0 12#切片访问x[0:5] array([0, 1, 2, 3, 4]) 1x[:5] array([0, 1, 2, 3, 4]) 1x[1:] array([1, 2, 3, 4, 5, 6, 7, 8, 9]) 1x[::2] array([0, 2, 4, 6, 8]) 1x[::-1] array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) 12#二维的切片访问X array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) 12#取前两行前三列X[:2,:3] array([[0, 1, 2], [5, 6, 7]]) 12#访问前两行，间隔为2X[:2,::2] array([[0, 2, 4], [5, 7, 9]]) 12#行倒数列倒数访问X[::-1,::-1] array([[14, 13, 12, 11, 10], [ 9, 8, 7, 6, 5], [ 4, 3, 2, 1, 0]]) 12#取第一行X[0] array([0, 1, 2, 3, 4]) 12#取一行X[0,:] array([0, 1, 2, 3, 4]) 12#取一列X[:,0] array([ 0, 5, 10]) 1234#创建一个子矩阵副本subX=X[:2,:3].copy()subX[0,0]=100subX array([[100, 1, 2], [ 5, 6, 7]]) 1X array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) Reshape1x.shape (10,) 1x.ndim 1 123#改变维度为2行5列A=x.reshape(2,5)A array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]) 12#改变维度为10行，自动计算剩下的一个参数x.reshape(10,-1) array([[0], [1], [2], [3], [4], [5], [6], [7], [8], [9]]) 1x.reshape(2,-1) array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]) 数组的合并与分割合并12x=np.array([1,2,3])y=np.array([3,2,1]) 1x array([1, 2, 3]) 1y array([3, 2, 1]) 12#合并np.concatenate([x,y]) array([1, 2, 3, 3, 2, 1]) 12A=np.array([[1,2,3], [4,5,6]]) 1np.concatenate([A,A],axis=0) array([[1, 2, 3], [4, 5, 6], [1, 2, 3], [4, 5, 6]]) 12#沿着列进行合并np.concatenate([A,A],axis=1) array([[1, 2, 3, 1, 2, 3], [4, 5, 6, 4, 5, 6]]) 1z=np.array([123,123,123]) 12B=np.concatenate([A,z.reshape(1,3)])B array([[ 1, 2, 3], [ 4, 5, 6], [123, 123, 123]]) 1np.vstack([A,z])#垂直叠加 array([[ 1, 2, 3], [ 4, 5, 6], [123, 123, 123]]) 12B=np.full((2,2),100)B array([[100, 100], [100, 100]]) 1np.hstack([A,B])#水平叠加 array([[ 1, 2, 3, 100, 100], [ 4, 5, 6, 100, 100]]) 分割12x=np.arange(10)x array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 1x1,x2,x3=np.split(x,[3,7]) 1x1 array([0, 1, 2]) 1x2 array([3, 4, 5, 6]) 1x3 array([7, 8, 9]) 12#分割两段x4,x5=np.split(x,[5]) 1x4 array([0, 1, 2, 3, 4]) 1x5 array([5, 6, 7, 8, 9]) 12A=np.arange(16).reshape(4,4)A array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]) 1A1,A2=np.split(A,[2]) 1A1 array([[0, 1, 2, 3], [4, 5, 6, 7]]) 1A2 array([[ 8, 9, 10, 11], [12, 13, 14, 15]]) 1up,low=np.vsplit(A,[2]) 1up array([[0, 1, 2, 3], [4, 5, 6, 7]]) 1low array([[ 8, 9, 10, 11], [12, 13, 14, 15]]) 12#水平分割left,right=np.hsplit(A,[3]) 1left array([[ 0, 1, 2], [ 4, 5, 6], [ 8, 9, 10], [12, 13, 14]]) 1right array([[ 3], [ 7], [11], [15]]) 12]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌浏览器插件推荐]]></title>
    <url>%2F2019%2F01%2F30%2F%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[适用于Github的插件 MathJax Plugin for GIthubGithub的Markdown不支持mathjax的公式渲染，转化为图片的格式内嵌到Markdown中会使工作量增大，可使用MathJax Plugin for Github解决,效果如图：使用前： 使用后： OctotreeGitHub可以在线查看项目中的源代码，文档，以及像图片一类的资源文件，但体验相当糟糕，只能重复地点进一个文件夹，再进入其中一个文件夹，如此循环,可使用octotree解决这一问题，效果如图： GitHub Hovercard使用这款插件，当你将鼠标停留在 GitHub 网站的用户头像或者仓库链接地址上时，会自动弹出一个悬浮框，带你提前预览基本信息。有点类似 StackOverflow 网站的用户头像的鼠标悬停效果Hovercard 插件支持的悬停位置更多，包括用户头像，仓库地址，Issue 链接，个人主页等，效果如图： Enhanced Github提供功能包括显示代码仓库的大小，以及其中每个文件的大小和下载链接。使用这款插件，我们再也不用因为需要某个单一文件而被迫下载整个项目源码，尤其是在网速不给力的时，效果如图： 广告净化AdBlock Plus/广告净化器轻松过滤视频广告，CSDN等页面的广告 内存节省神器One Tab用Chrome浏览器浏览网页时，因为页面还没有看完，或是需要反复查看等原因，而舍不得关闭页面，导致在Chrome浏览器中出现了很多标签，这些标签不仅查找起来不方便，还会占用很多内存。如果电脑内存比较少，就可能会出现内存不足的问题。这时，可以使用OneTab，将当前所有打开的标签页全部关闭，整合成为一个列表，显示在一个新打开的名称为”OneTab” 标签页中，查看全部标签也更轻松了。你可以点击恢复某个标签页，也可以全部恢复打开，效果如图： 效率提升MomentumMomentum插件提供自动更换壁纸，自带时钟，任务日历和工作清单等并且无广告，无弹窗，非常适合笔记本使用;效果如图： 其他插件推荐谷歌翻译效果不用多说! Grammarly英文输入时提供语法检查和拼写检查 微博图床上传图片到微博并生成外链的 Chrome 浏览器扩展 Fire Shot捕捉网页截图，可编辑并将它们保存为PDF，JPEG，GIF，PNG或BMP PDF Viewer使用HTML5直接在浏览器中显示PDF文件]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
</search>
