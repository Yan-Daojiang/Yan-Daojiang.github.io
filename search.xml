<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Amdahl定律]]></title>
    <url>%2F2019%2F10%2F19%2FAmdahl%E5%AE%9A%E5%BE%8B%2F</url>
    <content type="text"><![CDATA[Amdahl定律 Gene Amdahl, 计算领域的早期先锋之一， 对提升系统的某一部分性能所带来的效果做出了简单却有见地的观察，这个观察被称为Amdahl定律（Amdahl’s law, 阿姆达尔定律）. 定律的主要思想是当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度. 若系统执行某应用程序需要的时间为 $T_{\text {old }}$ .假设系统的某部分所需的执行时间与该随时间的比例为$\alpha$,而该部分系统性能提升比例为$k$.即该部分初始所需时间为$\alpha T_{\mathrm{old}}$，现在所需时间为$\left(\alpha T_{\mathrm{old}}\right) / k$.因此，总的执行时间为： T_{\text {new }}=(1-\alpha) T_{\text {old }}+\left(\alpha T_{\text {old }}\right) / k=T_{\text {old }}[(1-\alpha)+\alpha / k]​, 由此，计算加速比$S=T_{\mathrm{old}} / T_{\mathrm{new}}$为： S=\frac{1}{(1-\alpha)+\alpha / k}. 举例，考虑这样一种情况，系统的某个部分初始耗时为$60 \%(\alpha=0.6)​$，其加速比例因子为$3（k=3）​$。则我们获得的加速比为$1 /[0.4+0.6 / 3]=1.67​$倍.虽然我们对系统的一个主要部分进行了重大改进，但是获得的系统加速比却明显小于这部分的加速比. 通过上面的例子，也可以看出Amdahl定律的主要观点——要想加速整个系统，必须提升全系统中相当大部分的速度. 现在，我们考虑Amdahl定律的一个有趣的特殊情况：$k$趋向于$\infty$时的效果.这意味着我们可以取系统的某一个部分将其加速到一个点，在这个点上，这部分花费的时间可以忽略不计，于是得到 S_{\infty}=\frac{1}{(1-\alpha)}. 举例来说，如果$60 \%$的系统能够加速到不花时间的程度，我们获取的净加速比将仍只有$1 / 0.4=2.5 \times$. Amdahl定律描述了改善任何过程的一般原则，除了可以用在加速计算机系统方面之外，它还可以用在公司试图降低制造成本，或者学生想要提升绩点的平均值方面。也许它在计算机世界里是最有意义的，这里我们通常把性能提升$2​$倍或者更高的比列因子。这么高的比列因子只有通过优化系统的大部分组件才能获取.]]></content>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The key differences between pointers and references]]></title>
    <url>%2F2019%2F09%2F27%2FThe-key-differences-between-pointers-and-references%2F</url>
    <content type="text"><![CDATA[Explain the key differences between pointers and references. definition: the pointer is “points to” any other type. the reference is “another name” of an object. key difference: a reference is another name of an already existing object. a pointer is an object in its own right. Once initialized, a reference remains bound to its initial object. There is no way to rebind a reference to refer to a different object. a pointer can be assigned and copied. a reference always get the object to which the reference was initially bound. a single pointer can point to several different objects over its lifetime. a reference must be initialized. a pointer need not be initialized at the time it is defined. Usage advise: check here]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重定向]]></title>
    <url>%2F2019%2F09%2F20%2F%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[重定向 命令行最酷的功能—I/O重定向，这个功能可把命令行的输入重定向为从文件的内容，也可以将命令行的输出结果重定向到文件中。如果将多个命令行关联起来，还将相乘非常强大的命令—管道. 标准输入、标准输出和标准错误I/O重定向功能可以改变输出内容发送的目的地，也可以改变输入的来源，通常，输出显示在屏幕，输入来自于键盘，但是使用I/O重定向可以改变这一惯例。 标准输出重定向I/O重定向功能可以重新定义标准输出内容发送到哪里，使用重定向操作符&gt;后面接文件名就可将标准输出重定向到另一个文件中。仅仅使用了重定向符，前面不加任何命令就可以删除一个已经存在的文件内容或者创建一个新的空文件。 如果需要从文件的尾部进行添加输出内容，可以使用重定向符&gt;&gt;来实现。 标准错误重定向一个程序可以将生成的输出发送到任意文件流中，如果将这些文件流分别对应标准输入文件，标准输出文件和标准错误文件，那么在shell将在内部用文件描述符分别索引他们为0、1、2。标准错误等同于文件描述符2，所以可以用这种表示法来重定向标准错误，如ls -l /bin/usr 2&gt;ls_error.txt. 将标准输出和标准错误重定向到同个文件需要将标准输出和标准初五重定向到同个文件有两种方法，这里仅记录一种，使用&amp;&gt;将标准输出和标准错误都定向到文件中。 处理不想要的输出有时命令执行后并不希望得到输出，而是想把这个输出丢弃，系统提供了一种方法，即通过吧输出重定向到一个称为/dev/null的特殊文件来实现。 标准输入重定向先介绍一个命令——cat，cat命令读取一个或者多个文件，并把他们复制到标准输出文件中。 由于cat可以接受多个文件作为输入参数，所以可以用来吧文件连接到一起，例如cat movew.mpeg.0* &gt; movie.mepg. 如果cat命令没有任何参数，将从标准输入读取内容，即从键盘等待输入。（Ctrl-D可以告知已经到达标准输入的文件尾）。 下面的一个示例展示标准输入的重定向cat &lt; test.txt,使用重定向符&lt;将标准输入员变为text.txt文件。 管道命令从标准输入到读取数据，并将数据发送到标准输出的能力，是使用了名为管道的shell特性。使用管道操作符|可以吧一个名利的标准输出传送到另一个命令的标准输入中，使用方式为command1 | command2,例如ls -l /usr/bin | less. 过滤器管道功能常用来度数据进行复杂的操作，也可以将多条命令合在一起构成一个管道，这种用到的命令通常被称为过滤器。 过滤器接受输入，按照某种方式对输入进行改变，然后再输出它，例如ls /bin /usr/bin | sort |less. 报告或忽略文件中重复的行uniq命令常和sort命令结合使用，uniq接受来自标准输入或者某个单一文件名参数对用的已经排好序的数据列表。默认情况下，该命令删除列表中重复的行，因此在管道中添加uniq命令，可以确保所有的列表中没有重复的行，例如ls /bin /usr/bin | sort | uniq | less. 如果想要查看重复行列表可以在命令后面添加-d选项,如ls /bin /usr/bin | sort | uniq -d | less. 打印行数，字数和字节数wc命令用来显示文件中包含的行数，字数和字节数，如wc output.txt,使用-l选项将只报告行数。 打印匹配行grep是一个强大的程序，用来在文件中查找匹配的文本，使用方式如下： grep pattern [file...],grep能够匹配的模式内容可以是非常复杂的。grep命令还有一对非常方便的选项:-i使得搜索时忽略大小写，-v使得只输出和模式不匹配的行。 打印文件的开头/结尾部分head/tail命令默认处处文件的前/后10行，使用-n选项可以调整输出选项，例如head -n 5 output.txt. tail中有个选项可以用来实时查看文件，该选项在观察被写入的日志文件进展状态非常方便。 例如tail -f /var/log/message,使用-f选项，tail将持续监视这个文件，一旦添加了新行，新行就会立即显示在屏幕上（该动作在ctrl-c后停止）。 从stdin读取数据，并同时输出到stdout和文件tee程序读取标准输入，再把读取的内容复制到标准输出和一个或多个文件中，当在某个中间处理阶段来捕获管道中的内容时会很有用。例如：ls /usr/bin | tee ls.txt | grep zip,在过滤管道内容之前先使用tee命令来获取整个目录列表并输出到ls.txt文件中。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于命令]]></title>
    <url>%2F2019%2F09%2F19%2F%E5%85%B3%E4%BA%8E%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[什么是命令 命令不外乎有以下4中情况： 可执行程序 shell内置命令 shell函数：shell函数是合并到环境变量的小型shell脚本 alias命令：可以在其他命令的基础上定义自己的命令 识别命令显示命令的类型type命令是shell内置命令，可以根据指定的命令名显示shell将要执行的命令类型，格式为type command 显示可执行程序的位置which命令可以确定一个可执行程序的准确位置（注：只适用于可执行程序，不适用与内置命令和命令别名） 获取命令文档获得shell内置命令的帮助文档bash为每个shell内置命令提供了一个内置的帮助工具，输入help然后输入shell内置命令的名称即可使用该帮助工具，如help cd 显示命令的使用信息很多可执行程序都支持--help选项，该选项描述了命令支持的语法和选项，如mkdir --help 显示程序手册页大多数供命令行使用的可执行文件，提供了一个称之为manual或man page的正式文档，可以使用一种称之为man的特殊分页程序查看，如man ls,在显示手册时，less命令都能奏效。 man命令显示的“手册文档”被分为多个部分，不仅包含用户命令，也包含管理命令，程序接口等，手册的安排结构如下表： 部分（section） 内容 1 用户命令 2 内核系统调用的程序接口 3 C库函数程序接口 4 特殊文件，如设备节点和驱动程序 5 文件格式 6 游戏和娱乐 7 其他杂项 8 系统管理命令 有时需要查看具体的部分，以查找我们需要的信息。例如当我们查找的有个文件格式同时是一个命令名时，这点就尤为重要，为指明具体部分，使用的方式为man section search_term，如man 5 passwd 显示合适的命令apropos—显示合适的命令，我们有时需要通过搜索参考手册列表，才进行基于某个搜索条目的匹配。例如使用floppy为搜索条目，搜索参考手册：apropos floppy. 在输出中，第一个字段为手册页的名称，第二个字段显示部分。 注意：带有-k选项的man命令和apropos命令功能上基本一致. 显示命令的简要描述whatis显示匹配具体关键字的手册页的名字和一行描述。 显示程序的info条目GNU项目提供了info页面来代替手册文档，info页面使用超链接与网页的结构类似。 info程序读取info文件，该文件为属性结构，分为单独的节点，每个结点包含一个主题。info文件包含的的超链接可以实现节点间的跳转，通过星号识别超链接，回车跳转。下面是info命令： 命令 功能 ? 显示命令帮助 PAGE UP或BACKSPACE 返回上一页 PAGE DOWN或Spacebar 翻到下一页 n 显示下个节点 p 显示上个节点 u 显示目前显示节点的父节点 ENTER 进入光标所指超链接 q 退出 README和其他程序文档系统中安装的很多软件包都有自己的文档文件，他们存放在/usr/share/doc目录中。大部分以纯文本形式存储，可以用less命令查看，可能遇到有些以.gz扩展名结尾，表明经过gzip压缩程序压缩，可以用zless来显示由gzip压缩的文本文件内容。 使用别名创建自己的命令命令行技巧通过分号分隔多条命令就可以将多条命令输入在一行中，command1;command2;command3... 创建自己的命令我们可以通过alias命令将多条命令整合成一条命令。首先需要为新命令虚构一个名字（输入前最好检查虚构的新名称是否已经被使用了），然后按照alias newname=&#39;command1;command2...&#39;这个结构进行创建；如果要删除别名可以使用unalias命令。 当shell会话结束时，别名也会随之消失，但是我们可以将向文件中添加别名，每次登陆系统时，这些文件会建立系统环境。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql通配符]]></title>
    <url>%2F2019%2F09%2F18%2FMysql%E9%80%9A%E9%85%8D%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[使用通配符进行过滤 LIKE 操作符利用通配符可以创建比较特定的数据搜索模式。 为在搜索子句中使用通配符，必须使用LIKE操作符。LIKE指示MySQL，后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较。 百分号通配符在搜索串中，% 表示任何字符出现任何次数（%代表搜索模式中给定位置的0个、1个或多个字符） 通配符可在搜索模式中的任意位置使用，并且可以使用多个通配符。 虽然似乎%通配符可以匹配任何东西，但有一个例外,即NULL 下划线通配符下划线_匹配单个字符而不是多个字符（总是匹配一个字符，不能多也不能少） 通配符使用技巧 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。]]></content>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通配符]]></title>
    <url>%2F2019%2F09%2F18%2F%E9%80%9A%E9%85%8D%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[通配符 通配符 匹配项 * 匹配任意多个字符 ？ 匹配任意当个字符 [characters] 匹配任意一个属于字符集中的字符 [!characters] 匹配任意一个不属于字符集中的字符 [[:class:]] 匹配任意一个属于指定字符类中的字符 字符类 匹配项 [:alnum:] 匹配任意一个字母或者数字 [:alpha:] 匹配任意一个字母 [:digit:] 匹配任意一个数字 [:lower:] 匹配任意一个小写字母 [:upper:] 匹配任意一个大写字母 在使用rm命令的时候要小心的使用通配符]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件与目录操作]]></title>
    <url>%2F2019%2F09%2F18%2F%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[文件与目录操作 ls：列出目录内容 选项 长选项 含义 -a —all 列出所有的文件，包括隐藏文件 -d —directory 如果指定了一个目录，ls会列出目录中的内容而不是目录本身，将此选项与-l结合使用，可查看目录的详细信息而不是目录中的内容 -F —classify 列出的名字后面加上类型指示符 -h —human-readable 以长格式列出，以人们可读的方式而不是字节数来显示文件大小 -l 长格式显示结果 -r —reverse 以相反的顺序显示（一般，ls是字母升序显示结果） -S 按文件大小进行排序 -t 按修改时间排序 file:查看文件类型 less:查看文本文件 less命令 功能 PAGE UP 或 b 后翻一页 PAGE DOWN 或 Spacebar 前翻一页 向上（下）箭头 向上（下）一行 G 跳转文本文件末尾 lG或者g 跳转文本文件开头 /characters 向前查找指定的字符串 n 向前查找下一个出现的字符串（字符串为之前查找的） h 显示帮助 q 退出less cp:复制文件和目录 选项 含义 -a; —archive 复制文件和目录及其属性，包括所有权换和权限 -i; —interactive 提醒进行确认 -r 递归的复制文件及其内容 -u;—update 当将文件从一个目录复制到另一个目录时，只复制目录中不存在的文件或者是目标目录相应文件的更新文件 -v;—verbose 复制文件时，显示信息性消息 mv:移动或重命名文件和目录（很多选项与cp共享） mkdir：创建目录；可以同时创建多个目录 rm:删除文件或目录（删除目录时需要-r选项） ln：创建硬链接和符号链接（创建硬链接：ln file link；创建符号链接ln -s item link）]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy学习-2]]></title>
    <url>%2F2019%2F03%2F27%2FNumpy%E5%AD%A6%E4%B9%A0-2%2F</url>
    <content type="text"><![CDATA[直接由jupyter notebook导出 Numpy学习(2)1import numpy as np 矩阵的运算给定向量a=(0,1,2),对于向量中的每个元素乘以2 12a=np.array([0,1,2])a array([0, 1, 2]) 12*a array([0, 2, 4]) Universal Function12A=np.arange(1,16).reshape(3,5)A array([[ 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10], [11, 12, 13, 14, 15]]) 1A+1 array([[ 2, 3, 4, 5, 6], [ 7, 8, 9, 10, 11], [12, 13, 14, 15, 16]]) 1A*2 array([[ 2, 4, 6, 8, 10], [12, 14, 16, 18, 20], [22, 24, 26, 28, 30]]) 1A/2 array([[0.5, 1. , 1.5, 2. , 2.5], [3. , 3.5, 4. , 4.5, 5. ], [5.5, 6. , 6.5, 7. , 7.5]]) 1A**2 array([[ 1, 4, 9, 16, 25], [ 36, 49, 64, 81, 100], [121, 144, 169, 196, 225]], dtype=int32) 1A%2 array([[1, 0, 1, 0, 1], [0, 1, 0, 1, 0], [1, 0, 1, 0, 1]], dtype=int32) 11/A array([[1. , 0.5 , 0.33333333, 0.25 , 0.2 ], [0.16666667, 0.14285714, 0.125 , 0.11111111, 0.1 ], [0.09090909, 0.08333333, 0.07692308, 0.07142857, 0.06666667]]) 1np.abs(A) array([[ 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10], [11, 12, 13, 14, 15]]) 1np.sin(A) array([[ 0.84147098, 0.90929743, 0.14112001, -0.7568025 , -0.95892427], [-0.2794155 , 0.6569866 , 0.98935825, 0.41211849, -0.54402111], [-0.99999021, -0.53657292, 0.42016704, 0.99060736, 0.65028784]]) 1np.exp(A) array([[2.71828183e+00, 7.38905610e+00, 2.00855369e+01, 5.45981500e+01, 1.48413159e+02], [4.03428793e+02, 1.09663316e+03, 2.98095799e+03, 8.10308393e+03, 2.20264658e+04], [5.98741417e+04, 1.62754791e+05, 4.42413392e+05, 1.20260428e+06, 3.26901737e+06]]) 1np.power(3,A) array([[ 3, 9, 27, 81, 243], [ 729, 2187, 6561, 19683, 59049], [ 177147, 531441, 1594323, 4782969, 14348907]], dtype=int32) 1np.log2(A) array([[0. , 1. , 1.5849625 , 2. , 2.32192809], [2.5849625 , 2.80735492, 3. , 3.169925 , 3.32192809], [3.45943162, 3.5849625 , 3.70043972, 3.80735492, 3.9068906 ]]) 矩阵间的运算12A=np.arange(4).reshape(2,2)A array([[0, 1], [2, 3]]) 12B=np.full((2,2),10)B array([[10, 10], [10, 10]]) 1A+B array([[10, 11], [12, 13]]) 1A-B array([[-10, -9], [ -8, -7]]) 12# 对应元素的乘积A*B array([[ 0, 10], [20, 30]]) 12#对应元素之间的除法A/B array([[0. , 0.1], [0.2, 0.3]]) 12#矩阵的乘法A.dot(B) array([[10, 10], [50, 50]]) 12#矩阵的转置A.T array([[0, 2], [1, 3]]) 向量与矩阵的运算1A array([[0, 1], [2, 3]]) 12v=np.array([1,2])v array([1, 2]) 加123#向量与矩阵中的每一行相加v+A #数学中无意义 array([[1, 3], [3, 5]]) 1np.vstack([v]*A.shape[0])+A array([[1, 3], [3, 5]]) 1np.tile(v,(2,1))+A array([[1, 3], [3, 5]]) 乘法1v*A array([[0, 2], [2, 6]]) 12# 矩阵间的乘法v.dot(A) array([4, 7]) 1A.dot(v) #numpy自动的确定行向量和列向量 array([2, 8]) 矩阵的逆1A array([[0, 1], [2, 3]]) 1invA=np.linalg.inv(A) 1A.dot(invA) array([[1., 0.], [0., 1.]]) 12x=np.arange(0,16,1).reshape(2,8)x array([[ 0, 1, 2, 3, 4, 5, 6, 7], [ 8, 9, 10, 11, 12, 13, 14, 15]]) 123#求矩阵的伪逆pinvx=np.linalg.pinv(x)pinvx array([[-1.35416667e-01, 5.20833333e-02], [-1.01190476e-01, 4.16666667e-02], [-6.69642857e-02, 3.12500000e-02], [-3.27380952e-02, 2.08333333e-02], [ 1.48809524e-03, 1.04166667e-02], [ 3.57142857e-02, -1.04083409e-17], [ 6.99404762e-02, -1.04166667e-02], [ 1.04166667e-01, -2.08333333e-02]]) 1x.dot(pinvx) array([[ 1.00000000e+00, -2.49800181e-16], [ 0.00000000e+00, 1.00000000e+00]]) 聚合操作一维的聚合运算12L=np.random.random(100)L array([0.87573398, 0.67501167, 0.19874448, 0.45128579, 0.87728048, 0.3992231 , 0.04337321, 0.35165112, 0.09329798, 0.27841018, 0.89502298, 0.79592868, 0.72965371, 0.55066736, 0.39673235, 0.09025584, 0.4681407 , 0.12976291, 0.96644763, 0.37252674, 0.99482023, 0.48716849, 0.04322846, 0.357683 , 0.91251502, 0.18163644, 0.23667114, 0.51066678, 0.15199209, 0.48058338, 0.73668235, 0.68639835, 0.93008385, 0.4349003 , 0.41466393, 0.0474914 , 0.08494696, 0.05953704, 0.8110798 , 0.56379862, 0.85395394, 0.25940165, 0.01383781, 0.2305063 , 0.78717336, 0.71975633, 0.03448859, 0.30844727, 0.67978253, 0.61208165, 0.88428785, 0.85554152, 0.28244673, 0.13667229, 0.66524831, 0.58252952, 0.75194173, 0.77858238, 0.12959418, 0.50311045, 0.98024221, 0.19155677, 0.98363842, 0.77112865, 0.89358774, 0.43570674, 0.09156904, 0.64146335, 0.57384783, 0.30997722, 0.61071868, 0.05227516, 0.022356 , 0.35313323, 0.8889014 , 0.28444816, 0.70192023, 0.59703519, 0.18617025, 0.42949736, 0.53536229, 0.71035688, 0.61404413, 0.91394917, 0.7353239 , 0.42738586, 0.69434886, 0.53646667, 0.00187462, 0.12664177, 0.52950761, 0.79619012, 0.80728167, 0.68430105, 0.57447197, 0.73118737, 0.90417553, 0.37069038, 0.28074295, 0.45566072]) 1sum(L) #计算列表的和 50.26422002639282 1np.sum(L) 50.26422002639284 1np.min(L) 0.001874618596041655 1np.max(L) 0.994820231853337 二维的聚合运算123X=np.arange(16).reshape(4,4)X array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]) 1np.sum(X) 120 12#求每一列的和与每一行的和np.sum(X,axis=0) #注意此处的列上的和 array([24, 28, 32, 36]) 1np.sum(X,axis=1) array([ 6, 22, 38, 54]) 1np.prod(X) #乘积 0 1np.prod(X+1) 2004189184 12#均值np.mean(X) 7.5 12#中位数np.median(X) 7.5 12#求解百分位点np.percentile(X,100) 15.0 12#方差np.var(X) 21.25 12#标准差np.std(X) 4.6097722286464435 索引1x=np.random.normal(0,1,1000000) 1np.min(x) -4.632350126506717 1np.argmin(x) 85945 1x[np.argmin(x)] -4.632350126506717 排序和使用索引12x=np.arange(16)x array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) 123#进行乱序处理np.random.shuffle(x)x array([ 9, 15, 13, 3, 7, 10, 8, 4, 2, 6, 11, 14, 5, 0, 1, 12]) 12x.sort()x array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) 12X=np.random.randint(10,size=(4,4))X array([[9, 7, 3, 2], [1, 0, 3, 3], [6, 9, 0, 3], [0, 3, 8, 6]]) 1np.sort(X) array([[2, 3, 7, 9], [0, 1, 3, 3], [0, 3, 6, 9], [0, 3, 6, 8]]) 1np.sort(X,axis=1)#沿着列进行排序 array([[2, 3, 7, 9], [0, 1, 3, 3], [0, 3, 6, 9], [0, 3, 6, 8]]) 1np.sort(X,axis=0)#沿着行进行排序 array([[0, 0, 0, 2], [1, 3, 3, 3], [6, 7, 3, 3], [9, 9, 8, 6]]) 1x array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) 1np.random.shuffle(x) 1x array([ 0, 13, 6, 3, 10, 14, 15, 4, 11, 1, 2, 9, 12, 5, 7, 8]) 1np.argsort(x)#按照索引进行的排序 array([ 0, 9, 10, 3, 7, 13, 2, 14, 15, 11, 4, 8, 12, 1, 5, 6], dtype=int64) 1np.partition(x,3) #使用快排的partition array([ 0, 1, 2, 3, 4, 14, 15, 13, 11, 10, 6, 9, 12, 5, 7, 8]) 1np.argpartition(x,3) array([ 0, 9, 10, 3, 7, 5, 6, 1, 8, 4, 2, 11, 12, 13, 14, 15], dtype=int64) 1X array([[9, 7, 3, 2], [1, 0, 3, 3], [6, 9, 0, 3], [0, 3, 8, 6]]) 1np.argsort(X,axis=1) #返回的是索引值 array([[3, 2, 1, 0], [1, 0, 2, 3], [2, 3, 0, 1], [0, 1, 3, 2]], dtype=int64) 1np.argpartition(X,2,axis=1) array([[3, 2, 1, 0], [1, 0, 2, 3], [2, 3, 0, 1], [0, 1, 3, 2]], dtype=int64) Fancy Indexing12x=np.arange(16)x array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) 12ind=[3,4,8]x[ind] array([3, 4, 8]) 123ind=np.array([[0,2], [1,3]])x[ind] array([[0, 2], [1, 3]]) 12X=x.reshape(4,4)X array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]) 123row=np.array([0,1,2]) #存行所在的索引col=np.array([1,2,3]) #存列所在的索引X[row,col] array([ 1, 6, 11]) 1X[0,row] array([0, 1, 2]) 1X[:2,row] array([[0, 1, 2], [4, 5, 6]]) 12col=[True,False,True,True] #表示对0,2，3列感兴趣X[1:3,col] array([[ 4, 6, 7], [ 8, 10, 11]]) numpy.array的比较1x array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) 1x&lt;3 array([ True, True, True, False, False, False, False, False, False, False, False, False, False, False, False, False]) 1x==3 array([False, False, False, True, False, False, False, False, False, False, False, False, False, False, False, False]) 1X==7 array([[False, False, False, False], [False, False, False, True], [False, False, False, False], [False, False, False, False]]) 12]]></content>
      <categories>
        <category>Coding</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程乐趣与烦恼]]></title>
    <url>%2F2019%2F03%2F23%2F%E7%BC%96%E7%A8%8B%E4%B9%90%E8%B6%A3%E4%B8%8E%E7%83%A6%E6%81%BC%2F</url>
    <content type="text"><![CDATA[摘录自FrederickP.Brooks.Jr的《人月神话》 职业的乐趣&ensp; &ensp; 编程为什么有趣？作为回报，它的从业者期望得到什么样的快乐？首先是一种创建事物的纯粹快乐。如同小孩在玩泥巴时感到愉快一样，成年人喜欢创建事物，特别是自己进行设计。我想这种快乐是上帝创造世界的折射，一种呈现在每片独特、崭新的树叶和雪花上的喜悦。&ensp; &ensp; 其次，快乐来自于开发对其他人有用的东西。内心深处，我们期望其他人使用我们的劳动成果，并能对他们有所帮助。从这个方面，这同小孩用粘土为”爸爸办公室”捏制铅笔盒没有本质的区别。第三是整个过程体现出魔术般的力量—将相互啮合的零部件组装在一起，看到它们精妙地运行，得到预先所希望的结果。比起弹珠游戏或点唱机所具有的迷人魅力，程序化的计算机毫不逊色。&ensp; &ensp; 第四是学习的乐趣，来自于这项工作的非重复特性。人们所面临的问题，在某个或其它方面总有些不同。因而解决问题的人可以从中学习新的事物：有时是实践上的，有时是理论上的，或者兼而有之。&ensp; &ensp; 最后，乐趣还来自于工作在如此易于驾驭的介质上。程序员，就像诗人一样，几乎仅仅工作在单纯的思考中。程序员凭空地运用自己的想象，来建造自己的”城堡”。很少有这样的介质—创造的方式如此得灵活，如此得易于精炼和重建，如此得容易实现概念上的设想。（不过我们将会看到，容易驾驭的特性也有它自己的问题）然而程序毕竟同诗歌不同，它是实实在在的东西；可以移动和运行，能独立产生可见的输出；能打印结果，绘制图形，发出声音，移动支架。神话和传说中的魔术在我们的时代已变成了现实。在键盘上键入正确的咒语，屏幕会活动、变幻，显示出前所未有的或是已经存在的事物。&ensp; &ensp; 编程非常有趣，在于它不仅满足了我们内心深处进行创造的渴望，而且还愉悦了每个人内在的情感。 职业的苦恼&ensp; &ensp; 然而这个过程并不全都是喜悦。我们只有事先了解一些编程固有的烦恼，这样，当它们真的出现时，才能更加坦然地面对。&ensp; &ensp; 首先，必须追求完美。因为计算机也是以这样的方式来变戏法：如果咒语中的一个字符、一个停顿，没有与正确的形式一致，魔术就不会出现。（现实中，很少的人类活动要求完美，所以人类对它本来就不习惯。）实际上，我认为学习编程的最困难部分，是将做事的方式往追求完美的方向调整。&ensp; &ensp; 其次，是由他人来设定目标，供给资源，提供信息。编程人员很少能控制工作环境和工作目标。用管理的术语来说，个人的权威和他所承担的责任是不相配的。不过，似乎在所有的领域中，对要完成的工作，很少能提供与责任相一致的正式权威。而现实情况中，实际（相对于正式）的权威来自于每次任务的完成。&ensp; &ensp; 对于系统编程人员而言，对其他人的依赖是一件非常痛苦的事情。他依靠其他人的程序，而往往这些程序设计得并不合理，实现拙劣，发布不完整（没有源代码或测试用例），或者文档记录得很糟。所以，系统编程人员不得不花费时间去研究和修改，而它们在理想情况下本应该是可靠完整的。&ensp; &ensp; 下一个烦恼—概念性设计是有趣的，但寻找琐碎的bug却只是一项重复性的活动。伴随着创造性活动的，往往是枯燥沉闷的时间和艰苦的劳动。程序编制工作也不例外。另外，人们发现调试和查错往往是线性收敛的，或者更糟糕的是，具有二次方的复杂度。结果，测试一拖再拖，寻找最后一个错误比第一个错误将花费更多的时间。&ensp; &ensp; 最后一个苦恼，有时也是一种无奈—当投入了大量辛苦的劳动，产品在即将完成或者终于完成的时候，却已显得陈旧过时。可能是同事和竞争对手已在追逐新的、更好的构思；也许替代方案不仅仅是在构思，而且已经在安排了。&ensp; &ensp; 现实情况比上面所说的通常要好一些。当产品开发完成时，更优秀的新产品通常还不能投入使用，而仅仅是为大家谈论而另外，它同样需要数月的开发时间。事实上，只有实际需要时，才会用到最新的设想，因为所实现的系统已经能满足要求，体现了回报。&ensp; &ensp; 诚然，产品开发所基于的技术在不断地进步。一旦设计被冻结，在概念上就已经开始陈旧了。不过，实际产品需要一步一步按阶段实现。实现落后与否的判断应根据其它已有的系统，而不是未实现的概念。因此，我们所面临的挑战和任务是在现有的时间和有效的资源范围内，寻找解决实际问题的切实可行方案。&ensp; &ensp; 这，就是编程。一个许多人痛苦挣扎的焦油坑以及一种乐趣和苦恼共存的创造性活动。]]></content>
      <categories>
        <category>software engineering</category>
      </categories>
      <tags>
        <tag>software engineering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy学习(1)]]></title>
    <url>%2F2019%2F03%2F23%2FNumpy%E5%AD%A6%E4%B9%A0-1%2F</url>
    <content type="text"><![CDATA[直接由jupyter notebook导出 numpy.array基础1import numpy as np 12#版本号查看np.__version__ &#39;1.15.4&#39; 12nparr=np.array([i for i in range(10)])nparr array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 12#查看nparr[5] 5 12#查看类型nparr.dtype dtype(&#39;int32&#39;) 12nparr2=np.array([1,1.0])nparr2.dtype dtype(&#39;float64&#39;) 数组与矩阵的创建1np.zeros(10) array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) 1np.zeros(10).dtype dtype(&#39;float64&#39;) 1np.zeros((3,5)) array([[0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.]]) 1np.ones(shape=(3,5)) array([[1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.]]) 12#指定值创建np.full(shape=(3,5),fill_value=123) array([[123, 123, 123, 123, 123], [123, 123, 123, 123, 123], [123, 123, 123, 123, 123]]) arange1[i for i in range(0,20,2)] [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] 1np.arange(0,20,2) array([ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18]) 1np.arange(0,1,0.2) array([0. , 0.2, 0.4, 0.6, 0.8]) 12# arange默认0开始,步长为1np.arange(10) array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) linspace1np.linspace(0,20,10)#第三个值表示在0到20截出10个值 array([ 0. , 2.22222222, 4.44444444, 6.66666667, 8.88888889, 11.11111111, 13.33333333, 15.55555556, 17.77777778, 20. ]) 1np.linspace(0,20,11) array([ 0., 2., 4., 6., 8., 10., 12., 14., 16., 18., 20.]) random1np.random.randint(0,10) 9 1np.random.randint(0,10,size=10)#区间是左闭右开 array([4, 4, 3, 1, 8, 8, 9, 0, 6, 3]) 1np.random.randint(0,10,size=[3,5]) array([[2, 8, 7, 3, 8], [6, 7, 3, 2, 8], [2, 5, 8, 5, 3]]) 123#指定随机种子np.random.seed(666)np.random.randint(0,10,size=[3,5]) array([[2, 6, 9, 4, 3], [1, 0, 8, 7, 5], [2, 5, 5, 4, 8]]) 12np.random.seed(666)np.random.randint(0,10,size=[3,5]) array([[2, 6, 9, 4, 3], [1, 0, 8, 7, 5], [2, 5, 5, 4, 8]]) 12#生成均匀的随机数np.random.random(10) array([0.73159555, 0.8578588 , 0.76741234, 0.95323137, 0.29097383, 0.84778197, 0.3497619 , 0.92389692, 0.29489453, 0.52438061]) 12#生成符合正态分布的浮点数np.random.normal(0,1,10)#均值为0方差为1 array([-0.25584759, -1.76438083, -0.94249688, -1.58045861, 0.90472662, -0.82628327, 0.82101369, 0.36712592, 1.65399586, 0.13946473]) 1np.random.normal(10,100,2) array([-111.71535503, -89.49473667]) 数组的基本操作1import numpy as np 12x=np.arange(10)x array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 12X=np.arange(15).reshape(3,5)X array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) 基本属性1x.ndim 1 1X.ndim 2 1x.shape (10,) 1X.shape (3, 5) 1x.size 10 1X.size 15 数据访问1x array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 1x[3] 3 1x[-1] 9 1X array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) 1X[1][1]#不建议使用两个方括号访问 6 1X[(0,0)] 0 12#切片访问x[0:5] array([0, 1, 2, 3, 4]) 1x[:5] array([0, 1, 2, 3, 4]) 1x[1:] array([1, 2, 3, 4, 5, 6, 7, 8, 9]) 1x[::2] array([0, 2, 4, 6, 8]) 1x[::-1] array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) 12#二维的切片访问X array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) 12#取前两行前三列X[:2,:3] array([[0, 1, 2], [5, 6, 7]]) 12#访问前两行，间隔为2X[:2,::2] array([[0, 2, 4], [5, 7, 9]]) 12#行倒数列倒数访问X[::-1,::-1] array([[14, 13, 12, 11, 10], [ 9, 8, 7, 6, 5], [ 4, 3, 2, 1, 0]]) 12#取第一行X[0] array([0, 1, 2, 3, 4]) 12#取一行X[0,:] array([0, 1, 2, 3, 4]) 12#取一列X[:,0] array([ 0, 5, 10]) 1234#创建一个子矩阵副本subX=X[:2,:3].copy()subX[0,0]=100subX array([[100, 1, 2], [ 5, 6, 7]]) 1X array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) Reshape1x.shape (10,) 1x.ndim 1 123#改变维度为2行5列A=x.reshape(2,5)A array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]) 12#改变维度为10行，自动计算剩下的一个参数x.reshape(10,-1) array([[0], [1], [2], [3], [4], [5], [6], [7], [8], [9]]) 1x.reshape(2,-1) array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]) 数组的合并与分割合并12x=np.array([1,2,3])y=np.array([3,2,1]) 1x array([1, 2, 3]) 1y array([3, 2, 1]) 12#合并np.concatenate([x,y]) array([1, 2, 3, 3, 2, 1]) 12A=np.array([[1,2,3], [4,5,6]]) 1np.concatenate([A,A],axis=0) array([[1, 2, 3], [4, 5, 6], [1, 2, 3], [4, 5, 6]]) 12#沿着列进行合并np.concatenate([A,A],axis=1) array([[1, 2, 3, 1, 2, 3], [4, 5, 6, 4, 5, 6]]) 1z=np.array([123,123,123]) 12B=np.concatenate([A,z.reshape(1,3)])B array([[ 1, 2, 3], [ 4, 5, 6], [123, 123, 123]]) 1np.vstack([A,z])#垂直叠加 array([[ 1, 2, 3], [ 4, 5, 6], [123, 123, 123]]) 12B=np.full((2,2),100)B array([[100, 100], [100, 100]]) 1np.hstack([A,B])#水平叠加 array([[ 1, 2, 3, 100, 100], [ 4, 5, 6, 100, 100]]) 分割12x=np.arange(10)x array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 1x1,x2,x3=np.split(x,[3,7]) 1x1 array([0, 1, 2]) 1x2 array([3, 4, 5, 6]) 1x3 array([7, 8, 9]) 12#分割两段x4,x5=np.split(x,[5]) 1x4 array([0, 1, 2, 3, 4]) 1x5 array([5, 6, 7, 8, 9]) 12A=np.arange(16).reshape(4,4)A array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]) 1A1,A2=np.split(A,[2]) 1A1 array([[0, 1, 2, 3], [4, 5, 6, 7]]) 1A2 array([[ 8, 9, 10, 11], [12, 13, 14, 15]]) 1up,low=np.vsplit(A,[2]) 1up array([[0, 1, 2, 3], [4, 5, 6, 7]]) 1low array([[ 8, 9, 10, 11], [12, 13, 14, 15]]) 12#水平分割left,right=np.hsplit(A,[3]) 1left array([[ 0, 1, 2], [ 4, 5, 6], [ 8, 9, 10], [12, 13, 14]]) 1right array([[ 3], [ 7], [11], [15]]) 12]]></content>
      <categories>
        <category>Coding</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌浏览器插件推荐]]></title>
    <url>%2F2019%2F01%2F30%2F%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[适用于Github的插件 MathJax Plugin for GIthubGithub的Markdown不支持mathjax的公式渲染，转化为图片的格式内嵌到Markdown中会使工作量增大，可使用MathJax Plugin for Github解决,效果如图：使用前： 使用后： OctotreeGitHub可以在线查看项目中的源代码，文档，以及像图片一类的资源文件，但体验相当糟糕，只能重复地点进一个文件夹，再进入其中一个文件夹，如此循环,可使用octotree解决这一问题，效果如图： GitHub Hovercard使用这款插件，当你将鼠标停留在 GitHub 网站的用户头像或者仓库链接地址上时，会自动弹出一个悬浮框，带你提前预览基本信息。有点类似 StackOverflow 网站的用户头像的鼠标悬停效果Hovercard 插件支持的悬停位置更多，包括用户头像，仓库地址，Issue 链接，个人主页等，效果如图： Enhanced Github提供功能包括显示代码仓库的大小，以及其中每个文件的大小和下载链接。使用这款插件，我们再也不用因为需要某个单一文件而被迫下载整个项目源码，尤其是在网速不给力的时，效果如图： 广告净化AdBlock Plus/广告净化器轻松过滤视频广告，CSDN等页面的广告 内存节省神器One Tab用Chrome浏览器浏览网页时，因为页面还没有看完，或是需要反复查看等原因，而舍不得关闭页面，导致在Chrome浏览器中出现了很多标签，这些标签不仅查找起来不方便，还会占用很多内存。如果电脑内存比较少，就可能会出现内存不足的问题。这时，可以使用OneTab，将当前所有打开的标签页全部关闭，整合成为一个列表，显示在一个新打开的名称为”OneTab” 标签页中，查看全部标签也更轻松了。你可以点击恢复某个标签页，也可以全部恢复打开，效果如图： 效率提升MomentumMomentum插件提供自动更换壁纸，自带时钟，任务日历和工作清单等并且无广告，无弹窗，非常适合笔记本使用;效果如图： 其他插件推荐谷歌翻译效果不用多说! Grammarly英文输入时提供语法检查和拼写检查 微博图床上传图片到微博并生成外链的 Chrome 浏览器扩展 Fire Shot捕捉网页截图，可编辑并将它们保存为PDF，JPEG，GIF，PNG或BMP PDF Viewer使用HTML5直接在浏览器中显示PDF文件]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
</search>
