<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[通配符]]></title>
    <url>%2F2019%2F09%2F18%2F%E9%80%9A%E9%85%8D%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[通配符 通配符 匹配项 * 匹配任意多个字符 ？ 匹配任意当个字符 [characters] 匹配任意一个属于字符集中的字符 [!characters] 匹配任意一个不属于字符集中的字符 [[:class:]] 匹配任意一个属于指定字符类中的字符 字符类 匹配项 [:alnum:] 匹配任意一个字母或者数字 [:alpha:] 匹配任意一个字母 [:digit:] 匹配任意一个数字 [:lower:] 匹配任意一个小写字母 [:upper:] 匹配任意一个大写字母 在使用rm命令的时候要小心的使用通配符]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件与目录操作]]></title>
    <url>%2F2019%2F09%2F18%2F%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[文件与目录操作 ls：列出目录内容 选项 长选项 含义 -a –all 列出所有的文件，包括隐藏文件 -d –directory 如果指定了一个目录，ls会列出目录中的内容而不是目录本身，将此选项与-l结合使用，可查看目录的详细信息而不是目录中的内容 -F –classify 列出的名字后面加上类型指示符 -h –human-readable 以长格式列出，以人们可读的方式而不是字节数来显示文件大小 -l 长格式显示结果 -r –reverse 以相反的顺序显示（一般，ls是字母升序显示结果） -S 按文件大小进行排序 -t 按修改时间排序 file:查看文件类型 less:查看文本文件 less命令 功能 PAGE UP 或 b 后翻一页 PAGE DOWN 或 Spacebar 前翻一页 向上（下）箭头 向上（下）一行 G 跳转文本文件末尾 lG或者g 跳转文本文件开头 /characters 向前查找指定的字符串 n 向前查找下一个出现的字符串（字符串为之前查找的） h 显示帮助 q 退出less cp:复制文件和目录 选项 含义 -a; –archive 复制文件和目录及其属性，包括所有权换和权限 -i; –interactive 提醒进行确认 -r 递归的复制文件及其内容 -u;–update 当将文件从一个目录复制到另一个目录时，只复制目录中不存在的文件或者是目标目录相应文件的更新文件 -v;–verbose 复制文件时，显示信息性消息 mv:移动或重命名文件和目录（很多选项与cp共享） mkdir：创建目录；可以同时创建多个目录 rm:删除文件或目录（删除目录时需要-r选项） ln：创建硬链接和符号链接（创建硬链接：ln file link；创建符号链接ln -s item link）]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy学习-2]]></title>
    <url>%2F2019%2F03%2F27%2FNumpy%E5%AD%A6%E4%B9%A0-2%2F</url>
    <content type="text"><![CDATA[直接由jupyter notebook导出 Numpy学习(2)1import numpy as np 矩阵的运算给定向量a=(0,1,2),对于向量中的每个元素乘以2 12a=np.array([0,1,2])a array([0, 1, 2]) 12*a array([0, 2, 4]) Universal Function12A=np.arange(1,16).reshape(3,5)A array([[ 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10], [11, 12, 13, 14, 15]]) 1A+1 array([[ 2, 3, 4, 5, 6], [ 7, 8, 9, 10, 11], [12, 13, 14, 15, 16]]) 1A*2 array([[ 2, 4, 6, 8, 10], [12, 14, 16, 18, 20], [22, 24, 26, 28, 30]]) 1A/2 array([[0.5, 1. , 1.5, 2. , 2.5], [3. , 3.5, 4. , 4.5, 5. ], [5.5, 6. , 6.5, 7. , 7.5]]) 1A**2 array([[ 1, 4, 9, 16, 25], [ 36, 49, 64, 81, 100], [121, 144, 169, 196, 225]], dtype=int32) 1A%2 array([[1, 0, 1, 0, 1], [0, 1, 0, 1, 0], [1, 0, 1, 0, 1]], dtype=int32) 11/A array([[1. , 0.5 , 0.33333333, 0.25 , 0.2 ], [0.16666667, 0.14285714, 0.125 , 0.11111111, 0.1 ], [0.09090909, 0.08333333, 0.07692308, 0.07142857, 0.06666667]]) 1np.abs(A) array([[ 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10], [11, 12, 13, 14, 15]]) 1np.sin(A) array([[ 0.84147098, 0.90929743, 0.14112001, -0.7568025 , -0.95892427], [-0.2794155 , 0.6569866 , 0.98935825, 0.41211849, -0.54402111], [-0.99999021, -0.53657292, 0.42016704, 0.99060736, 0.65028784]]) 1np.exp(A) array([[2.71828183e+00, 7.38905610e+00, 2.00855369e+01, 5.45981500e+01, 1.48413159e+02], [4.03428793e+02, 1.09663316e+03, 2.98095799e+03, 8.10308393e+03, 2.20264658e+04], [5.98741417e+04, 1.62754791e+05, 4.42413392e+05, 1.20260428e+06, 3.26901737e+06]]) 1np.power(3,A) array([[ 3, 9, 27, 81, 243], [ 729, 2187, 6561, 19683, 59049], [ 177147, 531441, 1594323, 4782969, 14348907]], dtype=int32) 1np.log2(A) array([[0. , 1. , 1.5849625 , 2. , 2.32192809], [2.5849625 , 2.80735492, 3. , 3.169925 , 3.32192809], [3.45943162, 3.5849625 , 3.70043972, 3.80735492, 3.9068906 ]]) 矩阵间的运算12A=np.arange(4).reshape(2,2)A array([[0, 1], [2, 3]]) 12B=np.full((2,2),10)B array([[10, 10], [10, 10]]) 1A+B array([[10, 11], [12, 13]]) 1A-B array([[-10, -9], [ -8, -7]]) 12# 对应元素的乘积A*B array([[ 0, 10], [20, 30]]) 12#对应元素之间的除法A/B array([[0. , 0.1], [0.2, 0.3]]) 12#矩阵的乘法A.dot(B) array([[10, 10], [50, 50]]) 12#矩阵的转置A.T array([[0, 2], [1, 3]]) 向量与矩阵的运算1A array([[0, 1], [2, 3]]) 12v=np.array([1,2])v array([1, 2]) 加123#向量与矩阵中的每一行相加v+A #数学中无意义 array([[1, 3], [3, 5]]) 1np.vstack([v]*A.shape[0])+A array([[1, 3], [3, 5]]) 1np.tile(v,(2,1))+A array([[1, 3], [3, 5]]) 乘法1v*A array([[0, 2], [2, 6]]) 12# 矩阵间的乘法v.dot(A) array([4, 7]) 1A.dot(v) #numpy自动的确定行向量和列向量 array([2, 8]) 矩阵的逆1A array([[0, 1], [2, 3]]) 1invA=np.linalg.inv(A) 1A.dot(invA) array([[1., 0.], [0., 1.]]) 12x=np.arange(0,16,1).reshape(2,8)x array([[ 0, 1, 2, 3, 4, 5, 6, 7], [ 8, 9, 10, 11, 12, 13, 14, 15]]) 123#求矩阵的伪逆pinvx=np.linalg.pinv(x)pinvx array([[-1.35416667e-01, 5.20833333e-02], [-1.01190476e-01, 4.16666667e-02], [-6.69642857e-02, 3.12500000e-02], [-3.27380952e-02, 2.08333333e-02], [ 1.48809524e-03, 1.04166667e-02], [ 3.57142857e-02, -1.04083409e-17], [ 6.99404762e-02, -1.04166667e-02], [ 1.04166667e-01, -2.08333333e-02]]) 1x.dot(pinvx) array([[ 1.00000000e+00, -2.49800181e-16], [ 0.00000000e+00, 1.00000000e+00]]) 聚合操作一维的聚合运算12L=np.random.random(100)L array([0.87573398, 0.67501167, 0.19874448, 0.45128579, 0.87728048, 0.3992231 , 0.04337321, 0.35165112, 0.09329798, 0.27841018, 0.89502298, 0.79592868, 0.72965371, 0.55066736, 0.39673235, 0.09025584, 0.4681407 , 0.12976291, 0.96644763, 0.37252674, 0.99482023, 0.48716849, 0.04322846, 0.357683 , 0.91251502, 0.18163644, 0.23667114, 0.51066678, 0.15199209, 0.48058338, 0.73668235, 0.68639835, 0.93008385, 0.4349003 , 0.41466393, 0.0474914 , 0.08494696, 0.05953704, 0.8110798 , 0.56379862, 0.85395394, 0.25940165, 0.01383781, 0.2305063 , 0.78717336, 0.71975633, 0.03448859, 0.30844727, 0.67978253, 0.61208165, 0.88428785, 0.85554152, 0.28244673, 0.13667229, 0.66524831, 0.58252952, 0.75194173, 0.77858238, 0.12959418, 0.50311045, 0.98024221, 0.19155677, 0.98363842, 0.77112865, 0.89358774, 0.43570674, 0.09156904, 0.64146335, 0.57384783, 0.30997722, 0.61071868, 0.05227516, 0.022356 , 0.35313323, 0.8889014 , 0.28444816, 0.70192023, 0.59703519, 0.18617025, 0.42949736, 0.53536229, 0.71035688, 0.61404413, 0.91394917, 0.7353239 , 0.42738586, 0.69434886, 0.53646667, 0.00187462, 0.12664177, 0.52950761, 0.79619012, 0.80728167, 0.68430105, 0.57447197, 0.73118737, 0.90417553, 0.37069038, 0.28074295, 0.45566072]) 1sum(L) #计算列表的和 50.26422002639282 1np.sum(L) 50.26422002639284 1np.min(L) 0.001874618596041655 1np.max(L) 0.994820231853337 二维的聚合运算123X=np.arange(16).reshape(4,4)X array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]) 1np.sum(X) 120 12#求每一列的和与每一行的和np.sum(X,axis=0) #注意此处的列上的和 array([24, 28, 32, 36]) 1np.sum(X,axis=1) array([ 6, 22, 38, 54]) 1np.prod(X) #乘积 0 1np.prod(X+1) 2004189184 12#均值np.mean(X) 7.5 12#中位数np.median(X) 7.5 12#求解百分位点np.percentile(X,100) 15.0 12#方差np.var(X) 21.25 12#标准差np.std(X) 4.6097722286464435 索引1x=np.random.normal(0,1,1000000) 1np.min(x) -4.632350126506717 1np.argmin(x) 85945 1x[np.argmin(x)] -4.632350126506717 排序和使用索引12x=np.arange(16)x array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) 123#进行乱序处理np.random.shuffle(x)x array([ 9, 15, 13, 3, 7, 10, 8, 4, 2, 6, 11, 14, 5, 0, 1, 12]) 12x.sort()x array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) 12X=np.random.randint(10,size=(4,4))X array([[9, 7, 3, 2], [1, 0, 3, 3], [6, 9, 0, 3], [0, 3, 8, 6]]) 1np.sort(X) array([[2, 3, 7, 9], [0, 1, 3, 3], [0, 3, 6, 9], [0, 3, 6, 8]]) 1np.sort(X,axis=1)#沿着列进行排序 array([[2, 3, 7, 9], [0, 1, 3, 3], [0, 3, 6, 9], [0, 3, 6, 8]]) 1np.sort(X,axis=0)#沿着行进行排序 array([[0, 0, 0, 2], [1, 3, 3, 3], [6, 7, 3, 3], [9, 9, 8, 6]]) 1x array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) 1np.random.shuffle(x) 1x array([ 0, 13, 6, 3, 10, 14, 15, 4, 11, 1, 2, 9, 12, 5, 7, 8]) 1np.argsort(x)#按照索引进行的排序 array([ 0, 9, 10, 3, 7, 13, 2, 14, 15, 11, 4, 8, 12, 1, 5, 6], dtype=int64) 1np.partition(x,3) #使用快排的partition array([ 0, 1, 2, 3, 4, 14, 15, 13, 11, 10, 6, 9, 12, 5, 7, 8]) 1np.argpartition(x,3) array([ 0, 9, 10, 3, 7, 5, 6, 1, 8, 4, 2, 11, 12, 13, 14, 15], dtype=int64) 1X array([[9, 7, 3, 2], [1, 0, 3, 3], [6, 9, 0, 3], [0, 3, 8, 6]]) 1np.argsort(X,axis=1) #返回的是索引值 array([[3, 2, 1, 0], [1, 0, 2, 3], [2, 3, 0, 1], [0, 1, 3, 2]], dtype=int64) 1np.argpartition(X,2,axis=1) array([[3, 2, 1, 0], [1, 0, 2, 3], [2, 3, 0, 1], [0, 1, 3, 2]], dtype=int64) Fancy Indexing12x=np.arange(16)x array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) 12ind=[3,4,8]x[ind] array([3, 4, 8]) 123ind=np.array([[0,2], [1,3]])x[ind] array([[0, 2], [1, 3]]) 12X=x.reshape(4,4)X array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]) 123row=np.array([0,1,2]) #存行所在的索引col=np.array([1,2,3]) #存列所在的索引X[row,col] array([ 1, 6, 11]) 1X[0,row] array([0, 1, 2]) 1X[:2,row] array([[0, 1, 2], [4, 5, 6]]) 12col=[True,False,True,True] #表示对0,2，3列感兴趣X[1:3,col] array([[ 4, 6, 7], [ 8, 10, 11]]) numpy.array的比较1x array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) 1x&lt;3 array([ True, True, True, False, False, False, False, False, False, False, False, False, False, False, False, False]) 1x==3 array([False, False, False, True, False, False, False, False, False, False, False, False, False, False, False, False]) 1X==7 array([[False, False, False, False], [False, False, False, True], [False, False, False, False], [False, False, False, False]]) 12]]></content>
      <categories>
        <category>Coding</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程乐趣与烦恼]]></title>
    <url>%2F2019%2F03%2F23%2F%E7%BC%96%E7%A8%8B%E4%B9%90%E8%B6%A3%E4%B8%8E%E7%83%A6%E6%81%BC%2F</url>
    <content type="text"><![CDATA[摘录自FrederickP.Brooks.Jr的《人月神话》 职业的乐趣&ensp; &ensp; 编程为什么有趣？作为回报，它的从业者期望得到什么样的快乐？首先是一种创建事物的纯粹快乐。如同小孩在玩泥巴时感到愉快一样，成年人喜欢创建事物，特别是自己进行设计。我想这种快乐是上帝创造世界的折射，一种呈现在每片独特、崭新的树叶和雪花上的喜悦。&ensp; &ensp; 其次，快乐来自于开发对其他人有用的东西。内心深处，我们期望其他人使用我们的劳动成果，并能对他们有所帮助。从这个方面，这同小孩用粘土为”爸爸办公室”捏制铅笔盒没有本质的区别。第三是整个过程体现出魔术般的力量–将相互啮合的零部件组装在一起，看到它们精妙地运行，得到预先所希望的结果。比起弹珠游戏或点唱机所具有的迷人魅力，程序化的计算机毫不逊色。&ensp; &ensp; 第四是学习的乐趣，来自于这项工作的非重复特性。人们所面临的问题，在某个或其它方面总有些不同。因而解决问题的人可以从中学习新的事物：有时是实践上的，有时是理论上的，或者兼而有之。&ensp; &ensp; 最后，乐趣还来自于工作在如此易于驾驭的介质上。程序员，就像诗人一样，几乎仅仅工作在单纯的思考中。程序员凭空地运用自己的想象，来建造自己的”城堡”。很少有这样的介质–创造的方式如此得灵活，如此得易于精炼和重建，如此得容易实现概念上的设想。（不过我们将会看到，容易驾驭的特性也有它自己的问题）然而程序毕竟同诗歌不同，它是实实在在的东西；可以移动和运行，能独立产生可见的输出；能打印结果，绘制图形，发出声音，移动支架。神话和传说中的魔术在我们的时代已变成了现实。在键盘上键入正确的咒语，屏幕会活动、变幻，显示出前所未有的或是已经存在的事物。&ensp; &ensp; 编程非常有趣，在于它不仅满足了我们内心深处进行创造的渴望，而且还愉悦了每个人内在的情感。 职业的苦恼&ensp; &ensp; 然而这个过程并不全都是喜悦。我们只有事先了解一些编程固有的烦恼，这样，当它们真的出现时，才能更加坦然地面对。&ensp; &ensp; 首先，必须追求完美。因为计算机也是以这样的方式来变戏法：如果咒语中的一个字符、一个停顿，没有与正确的形式一致，魔术就不会出现。（现实中，很少的人类活动要求完美，所以人类对它本来就不习惯。）实际上，我认为学习编程的最困难部分，是将做事的方式往追求完美的方向调整。&ensp; &ensp; 其次，是由他人来设定目标，供给资源，提供信息。编程人员很少能控制工作环境和工作目标。用管理的术语来说，个人的权威和他所承担的责任是不相配的。不过，似乎在所有的领域中，对要完成的工作，很少能提供与责任相一致的正式权威。而现实情况中，实际（相对于正式）的权威来自于每次任务的完成。&ensp; &ensp; 对于系统编程人员而言，对其他人的依赖是一件非常痛苦的事情。他依靠其他人的程序，而往往这些程序设计得并不合理，实现拙劣，发布不完整（没有源代码或测试用例），或者文档记录得很糟。所以，系统编程人员不得不花费时间去研究和修改，而它们在理想情况下本应该是可靠完整的。&ensp; &ensp; 下一个烦恼–概念性设计是有趣的，但寻找琐碎的bug却只是一项重复性的活动。伴随着创造性活动的，往往是枯燥沉闷的时间和艰苦的劳动。程序编制工作也不例外。另外，人们发现调试和查错往往是线性收敛的，或者更糟糕的是，具有二次方的复杂度。结果，测试一拖再拖，寻找最后一个错误比第一个错误将花费更多的时间。&ensp; &ensp; 最后一个苦恼，有时也是一种无奈–当投入了大量辛苦的劳动，产品在即将完成或者终于完成的时候，却已显得陈旧过时。可能是同事和竞争对手已在追逐新的、更好的构思；也许替代方案不仅仅是在构思，而且已经在安排了。&ensp; &ensp; 现实情况比上面所说的通常要好一些。当产品开发完成时，更优秀的新产品通常还不能投入使用，而仅仅是为大家谈论而另外，它同样需要数月的开发时间。事实上，只有实际需要时，才会用到最新的设想，因为所实现的系统已经能满足要求，体现了回报。&ensp; &ensp; 诚然，产品开发所基于的技术在不断地进步。一旦设计被冻结，在概念上就已经开始陈旧了。不过，实际产品需要一步一步按阶段实现。实现落后与否的判断应根据其它已有的系统，而不是未实现的概念。因此，我们所面临的挑战和任务是在现有的时间和有效的资源范围内，寻找解决实际问题的切实可行方案。&ensp; &ensp; 这，就是编程。一个许多人痛苦挣扎的焦油坑以及一种乐趣和苦恼共存的创造性活动。]]></content>
      <categories>
        <category>software engineering</category>
      </categories>
      <tags>
        <tag>software engineering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy学习(1)]]></title>
    <url>%2F2019%2F03%2F23%2FNumpy%E5%AD%A6%E4%B9%A0-1%2F</url>
    <content type="text"><![CDATA[直接由jupyter notebook导出 numpy.array基础1import numpy as np 12#版本号查看np.__version__ &apos;1.15.4&apos; 12nparr=np.array([i for i in range(10)])nparr array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 12#查看nparr[5] 5 12#查看类型nparr.dtype dtype(&apos;int32&apos;) 12nparr2=np.array([1,1.0])nparr2.dtype dtype(&apos;float64&apos;) 数组与矩阵的创建1np.zeros(10) array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) 1np.zeros(10).dtype dtype(&apos;float64&apos;) 1np.zeros((3,5)) array([[0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.]]) 1np.ones(shape=(3,5)) array([[1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.]]) 12#指定值创建np.full(shape=(3,5),fill_value=123) array([[123, 123, 123, 123, 123], [123, 123, 123, 123, 123], [123, 123, 123, 123, 123]]) arange1[i for i in range(0,20,2)] [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] 1np.arange(0,20,2) array([ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18]) 1np.arange(0,1,0.2) array([0. , 0.2, 0.4, 0.6, 0.8]) 12# arange默认0开始,步长为1np.arange(10) array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) linspace1np.linspace(0,20,10)#第三个值表示在0到20截出10个值 array([ 0. , 2.22222222, 4.44444444, 6.66666667, 8.88888889, 11.11111111, 13.33333333, 15.55555556, 17.77777778, 20. ]) 1np.linspace(0,20,11) array([ 0., 2., 4., 6., 8., 10., 12., 14., 16., 18., 20.]) random1np.random.randint(0,10) 9 1np.random.randint(0,10,size=10)#区间是左闭右开 array([4, 4, 3, 1, 8, 8, 9, 0, 6, 3]) 1np.random.randint(0,10,size=[3,5]) array([[2, 8, 7, 3, 8], [6, 7, 3, 2, 8], [2, 5, 8, 5, 3]]) 123#指定随机种子np.random.seed(666)np.random.randint(0,10,size=[3,5]) array([[2, 6, 9, 4, 3], [1, 0, 8, 7, 5], [2, 5, 5, 4, 8]]) 12np.random.seed(666)np.random.randint(0,10,size=[3,5]) array([[2, 6, 9, 4, 3], [1, 0, 8, 7, 5], [2, 5, 5, 4, 8]]) 12#生成均匀的随机数np.random.random(10) array([0.73159555, 0.8578588 , 0.76741234, 0.95323137, 0.29097383, 0.84778197, 0.3497619 , 0.92389692, 0.29489453, 0.52438061]) 12#生成符合正态分布的浮点数np.random.normal(0,1,10)#均值为0方差为1 array([-0.25584759, -1.76438083, -0.94249688, -1.58045861, 0.90472662, -0.82628327, 0.82101369, 0.36712592, 1.65399586, 0.13946473]) 1np.random.normal(10,100,2) array([-111.71535503, -89.49473667]) 数组的基本操作1import numpy as np 12x=np.arange(10)x array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 12X=np.arange(15).reshape(3,5)X array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) 基本属性1x.ndim 1 1X.ndim 2 1x.shape (10,) 1X.shape (3, 5) 1x.size 10 1X.size 15 数据访问1x array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 1x[3] 3 1x[-1] 9 1X array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) 1X[1][1]#不建议使用两个方括号访问 6 1X[(0,0)] 0 12#切片访问x[0:5] array([0, 1, 2, 3, 4]) 1x[:5] array([0, 1, 2, 3, 4]) 1x[1:] array([1, 2, 3, 4, 5, 6, 7, 8, 9]) 1x[::2] array([0, 2, 4, 6, 8]) 1x[::-1] array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) 12#二维的切片访问X array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) 12#取前两行前三列X[:2,:3] array([[0, 1, 2], [5, 6, 7]]) 12#访问前两行，间隔为2X[:2,::2] array([[0, 2, 4], [5, 7, 9]]) 12#行倒数列倒数访问X[::-1,::-1] array([[14, 13, 12, 11, 10], [ 9, 8, 7, 6, 5], [ 4, 3, 2, 1, 0]]) 12#取第一行X[0] array([0, 1, 2, 3, 4]) 12#取一行X[0,:] array([0, 1, 2, 3, 4]) 12#取一列X[:,0] array([ 0, 5, 10]) 1234#创建一个子矩阵副本subX=X[:2,:3].copy()subX[0,0]=100subX array([[100, 1, 2], [ 5, 6, 7]]) 1X array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) Reshape1x.shape (10,) 1x.ndim 1 123#改变维度为2行5列A=x.reshape(2,5)A array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]) 12#改变维度为10行，自动计算剩下的一个参数x.reshape(10,-1) array([[0], [1], [2], [3], [4], [5], [6], [7], [8], [9]]) 1x.reshape(2,-1) array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]) 数组的合并与分割合并12x=np.array([1,2,3])y=np.array([3,2,1]) 1x array([1, 2, 3]) 1y array([3, 2, 1]) 12#合并np.concatenate([x,y]) array([1, 2, 3, 3, 2, 1]) 12A=np.array([[1,2,3], [4,5,6]]) 1np.concatenate([A,A],axis=0) array([[1, 2, 3], [4, 5, 6], [1, 2, 3], [4, 5, 6]]) 12#沿着列进行合并np.concatenate([A,A],axis=1) array([[1, 2, 3, 1, 2, 3], [4, 5, 6, 4, 5, 6]]) 1z=np.array([123,123,123]) 12B=np.concatenate([A,z.reshape(1,3)])B array([[ 1, 2, 3], [ 4, 5, 6], [123, 123, 123]]) 1np.vstack([A,z])#垂直叠加 array([[ 1, 2, 3], [ 4, 5, 6], [123, 123, 123]]) 12B=np.full((2,2),100)B array([[100, 100], [100, 100]]) 1np.hstack([A,B])#水平叠加 array([[ 1, 2, 3, 100, 100], [ 4, 5, 6, 100, 100]]) 分割12x=np.arange(10)x array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 1x1,x2,x3=np.split(x,[3,7]) 1x1 array([0, 1, 2]) 1x2 array([3, 4, 5, 6]) 1x3 array([7, 8, 9]) 12#分割两段x4,x5=np.split(x,[5]) 1x4 array([0, 1, 2, 3, 4]) 1x5 array([5, 6, 7, 8, 9]) 12A=np.arange(16).reshape(4,4)A array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]) 1A1,A2=np.split(A,[2]) 1A1 array([[0, 1, 2, 3], [4, 5, 6, 7]]) 1A2 array([[ 8, 9, 10, 11], [12, 13, 14, 15]]) 1up,low=np.vsplit(A,[2]) 1up array([[0, 1, 2, 3], [4, 5, 6, 7]]) 1low array([[ 8, 9, 10, 11], [12, 13, 14, 15]]) 12#水平分割left,right=np.hsplit(A,[3]) 1left array([[ 0, 1, 2], [ 4, 5, 6], [ 8, 9, 10], [12, 13, 14]]) 1right array([[ 3], [ 7], [11], [15]]) 12]]></content>
      <categories>
        <category>Coding</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌浏览器插件推荐]]></title>
    <url>%2F2019%2F01%2F30%2F%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[适用于Github的插件 MathJax Plugin for GIthubGithub的Markdown不支持mathjax的公式渲染，转化为图片的格式内嵌到Markdown中会使工作量增大，可使用MathJax Plugin for Github解决,效果如图：使用前： 使用后： OctotreeGitHub可以在线查看项目中的源代码，文档，以及像图片一类的资源文件，但体验相当糟糕，只能重复地点进一个文件夹，再进入其中一个文件夹，如此循环,可使用octotree解决这一问题，效果如图： GitHub Hovercard使用这款插件，当你将鼠标停留在 GitHub 网站的用户头像或者仓库链接地址上时，会自动弹出一个悬浮框，带你提前预览基本信息。有点类似 StackOverflow 网站的用户头像的鼠标悬停效果Hovercard 插件支持的悬停位置更多，包括用户头像，仓库地址，Issue 链接，个人主页等，效果如图： Enhanced Github提供功能包括显示代码仓库的大小，以及其中每个文件的大小和下载链接。使用这款插件，我们再也不用因为需要某个单一文件而被迫下载整个项目源码，尤其是在网速不给力的时，效果如图： 广告净化AdBlock Plus/广告净化器轻松过滤视频广告，CSDN等页面的广告 内存节省神器One Tab用Chrome浏览器浏览网页时，因为页面还没有看完，或是需要反复查看等原因，而舍不得关闭页面，导致在Chrome浏览器中出现了很多标签，这些标签不仅查找起来不方便，还会占用很多内存。如果电脑内存比较少，就可能会出现内存不足的问题。这时，可以使用OneTab，将当前所有打开的标签页全部关闭，整合成为一个列表，显示在一个新打开的名称为”OneTab” 标签页中，查看全部标签也更轻松了。你可以点击恢复某个标签页，也可以全部恢复打开，效果如图： 效率提升MomentumMomentum插件提供自动更换壁纸，自带时钟，任务日历和工作清单等并且无广告，无弹窗，非常适合笔记本使用;效果如图： 其他插件推荐谷歌翻译效果不用多说! Grammarly英文输入时提供语法检查和拼写检查 微博图床上传图片到微博并生成外链的 Chrome 浏览器扩展 Fire Shot捕捉网页截图，可编辑并将它们保存为PDF，JPEG，GIF，PNG或BMP PDF Viewer使用HTML5直接在浏览器中显示PDF文件]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
</search>
